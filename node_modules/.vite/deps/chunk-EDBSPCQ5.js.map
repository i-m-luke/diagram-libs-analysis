{
  "version": 3,
  "sources": ["../../object-refs/dist/index.js", "../../diagram-js/lib/model/index.js"],
  "sourcesContent": ["/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @param {Array<Object>} collection\n * @param {Refs} refs instance\n * @param {Object} property represented by the collection\n * @param {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\n/**\n * Checks if a given collection is extended\n *\n * @param {Array<Object>} collection\n *\n * @return {boolean}\n */\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nvar collection = {\n  __proto__: null,\n  extend: extend,\n  isExtended: isExtended\n};\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */\n\nexport { collection as Collection, Refs };\n", "import { assign } from 'min-dash';\nimport inherits from 'inherits-browser';\n\nimport { Refs } from 'object-refs';\n\nvar parentRefs = new Refs({ name: 'children', enumerable: true, collection: true }, { name: 'parent' }),\n    labelRefs = new Refs({ name: 'labels', enumerable: true, collection: true }, { name: 'labelTarget' }),\n    attacherRefs = new Refs({ name: 'attachers', collection: true }, { name: 'host' }),\n    outgoingRefs = new Refs({ name: 'outgoing', collection: true }, { name: 'source' }),\n    incomingRefs = new Refs({ name: 'incoming', collection: true }, { name: 'target' });\n\n/**\n * @typedef {import('./Types').Element} Element\n * @typedef {import('./Types').Shape} Shape\n * @typedef {import('./Types').Root} Root\n * @typedef {import('./Types').Label} Label\n * @typedef {import('./Types').Connection} Connection\n */\n\n/**\n * The basic graphical representation\n *\n * @class\n * @constructor\n */\nfunction ElementImpl() {\n\n  /**\n   * The object that backs up the shape\n   *\n   * @name Element#businessObject\n   * @type Object\n   */\n  Object.defineProperty(this, 'businessObject', {\n    writable: true\n  });\n\n\n  /**\n   * Single label support, will mapped to multi label array\n   *\n   * @name Element#label\n   * @type Object\n   */\n  Object.defineProperty(this, 'label', {\n    get: function() {\n      return this.labels[0];\n    },\n    set: function(newLabel) {\n\n      var label = this.label,\n          labels = this.labels;\n\n      if (!newLabel && label) {\n        labels.remove(label);\n      } else {\n        labels.add(newLabel, 0);\n      }\n    }\n  });\n\n  /**\n   * The parent shape\n   *\n   * @name Element#parent\n   * @type Shape\n   */\n  parentRefs.bind(this, 'parent');\n\n  /**\n   * The list of labels\n   *\n   * @name Element#labels\n   * @type Label\n   */\n  labelRefs.bind(this, 'labels');\n\n  /**\n   * The list of outgoing connections\n   *\n   * @name Element#outgoing\n   * @type Array<Connection>\n   */\n  outgoingRefs.bind(this, 'outgoing');\n\n  /**\n   * The list of incoming connections\n   *\n   * @name Element#incoming\n   * @type Array<Connection>\n   */\n  incomingRefs.bind(this, 'incoming');\n}\n\n\n/**\n * A graphical object\n *\n * @class\n * @constructor\n *\n * @extends ElementImpl\n */\nfunction ShapeImpl() {\n  ElementImpl.call(this);\n\n  /**\n   * Indicates frame shapes\n   *\n   * @name ShapeImpl#isFrame\n   * @type boolean\n   */\n\n  /**\n   * The list of children\n   *\n   * @name ShapeImpl#children\n   * @type Element[]\n   */\n  parentRefs.bind(this, 'children');\n\n  /**\n   * @name ShapeImpl#host\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'host');\n\n  /**\n   * @name ShapeImpl#attachers\n   * @type Shape\n   */\n  attacherRefs.bind(this, 'attachers');\n}\n\ninherits(ShapeImpl, ElementImpl);\n\n\n/**\n * A root graphical object\n *\n * @class\n * @constructor\n *\n * @extends ElementImpl\n */\nfunction RootImpl() {\n  ElementImpl.call(this);\n\n  /**\n   * The list of children\n   *\n   * @name RootImpl#children\n   * @type Element[]\n   */\n  parentRefs.bind(this, 'children');\n}\n\ninherits(RootImpl, ShapeImpl);\n\n\n/**\n * A label for an element\n *\n * @class\n * @constructor\n *\n * @extends ShapeImpl\n */\nfunction LabelImpl() {\n  ShapeImpl.call(this);\n\n  /**\n   * The labeled element\n   *\n   * @name LabelImpl#labelTarget\n   * @type Element\n   */\n  labelRefs.bind(this, 'labelTarget');\n}\n\ninherits(LabelImpl, ShapeImpl);\n\n\n/**\n * A connection between two elements\n *\n * @class\n * @constructor\n *\n * @extends ElementImpl\n */\nfunction ConnectionImpl() {\n  ElementImpl.call(this);\n\n  /**\n   * The element this connection originates from\n   *\n   * @name ConnectionImpl#source\n   * @type Element\n   */\n  outgoingRefs.bind(this, 'source');\n\n  /**\n   * The element this connection points to\n   *\n   * @name ConnectionImpl#target\n   * @type Element\n   */\n  incomingRefs.bind(this, 'target');\n}\n\ninherits(ConnectionImpl, ElementImpl);\n\n\nvar types = {\n  connection: ConnectionImpl,\n  shape: ShapeImpl,\n  label: LabelImpl,\n  root: RootImpl\n};\n\n/**\n * Creates a root element.\n *\n * @overlord\n *\n * @example\n *\n * ```javascript\n * import * as Model from 'diagram-js/lib/model';\n *\n * const root = Model.create('root', {\n *   x: 100,\n *   y: 100,\n *   width: 100,\n *   height: 100\n * });\n * ```\n *\n * @param {'root'} type\n * @param {any} [attrs]\n *\n * @return {Root}\n */\n\n/**\n * Creates a connection.\n *\n * @overlord\n *\n * @example\n *\n * ```javascript\n * import * as Model from 'diagram-js/lib/model';\n *\n * const connection = Model.create('connection', {\n *   waypoints: [\n *     { x: 100, y: 100 },\n *     { x: 200, y: 100 }\n *   ]\n * });\n * ```\n *\n * @param {'connection'} type\n * @param {any} [attrs]\n *\n * @return {Connection}\n */\n\n/**\n * Creates a shape.\n *\n * @overlord\n *\n * @example\n *\n * ```javascript\n * import * as Model from 'diagram-js/lib/model';\n *\n * const shape = Model.create('shape', {\n *   x: 100,\n *   y: 100,\n *   width: 100,\n *   height: 100\n * });\n * ```\n *\n * @param {'shape'} type\n * @param {any} [attrs]\n *\n * @return {Shape}\n */\n\n/**\n * Creates a label.\n *\n * @example\n *\n * ```javascript\n * import * as Model from 'diagram-js/lib/model';\n *\n * const label = Model.create('label', {\n *   x: 100,\n *   y: 100,\n *   width: 100,\n *   height: 100,\n *   labelTarget: shape\n * });\n * ```\n *\n * @param {'label'} type\n * @param {Object} [attrs]\n *\n * @return {Label}\n */\nexport function create(type, attrs) {\n  var Type = types[type];\n  if (!Type) {\n    throw new Error('unknown type: <' + type + '>');\n  }\n  return assign(new Type(), attrs);\n}\n\n/**\n * Checks whether an object is a model instance.\n *\n * @param {any} obj\n *\n * @return {boolean}\n */\nexport function isModelElement(obj) {\n  return obj instanceof ElementImpl;\n}"],
  "mappings": "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",
  "names": ["e"]
}
