{
  "version": 3,
  "sources": ["../../diagram-js/lib/core/EventBus.js"],
  "sourcesContent": ["import {\n  isFunction,\n  isArray,\n  isNumber,\n  bind,\n  assign\n} from 'min-dash';\n\nvar FN_REF = '__fn';\n\nvar DEFAULT_PRIORITY = 1000;\n\nvar slice = Array.prototype.slice;\n\n/**\n * @typedef { {\n *   stopPropagation(): void;\n *   preventDefault(): void;\n *   cancelBubble: boolean;\n *   defaultPrevented: boolean;\n *   returnValue: any;\n * } } Event\n */\n\n/**\n * @template E\n *\n * @typedef { (event: E & Event, ...any) => any } EventBusEventCallback\n */\n\n/**\n * @typedef { {\n *  priority: number;\n *  next: EventBusListener | null;\n *  callback: EventBusEventCallback<any>;\n * } } EventBusListener\n */\n\n/**\n * A general purpose event bus.\n *\n * This component is used to communicate across a diagram instance.\n * Other parts of a diagram can use it to listen to and broadcast events.\n *\n *\n * ## Registering for Events\n *\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\n * methods to register for events. {@link EventBus#off} can be used to\n * remove event registrations. Listeners receive an instance of {@link Event}\n * as the first argument. It allows them to hook into the event execution.\n *\n * ```javascript\n *\n * // listen for event\n * eventBus.on('foo', function(event) {\n *\n *   // access event type\n *   event.type; // 'foo'\n *\n *   // stop propagation to other listeners\n *   event.stopPropagation();\n *\n *   // prevent event default\n *   event.preventDefault();\n * });\n *\n * // listen for event with custom payload\n * eventBus.on('bar', function(event, payload) {\n *   console.log(payload);\n * });\n *\n * // listen for event returning value\n * eventBus.on('foobar', function(event) {\n *\n *   // stop event propagation + prevent default\n *   return false;\n *\n *   // stop event propagation + return custom result\n *   return {\n *     complex: 'listening result'\n *   };\n * });\n *\n *\n * // listen with custom priority (default=1000, higher is better)\n * eventBus.on('priorityfoo', 1500, function(event) {\n *   console.log('invoked first!');\n * });\n *\n *\n * // listen for event and pass the context (`this`)\n * eventBus.on('foobar', function(event) {\n *   this.foo();\n * }, this);\n * ```\n *\n *\n * ## Emitting Events\n *\n * Events can be emitted via the event bus using {@link EventBus#fire}.\n *\n * ```javascript\n *\n * // false indicates that the default action\n * // was prevented by listeners\n * if (eventBus.fire('foo') === false) {\n *   console.log('default has been prevented!');\n * };\n *\n *\n * // custom args + return value listener\n * eventBus.on('sum', function(event, a, b) {\n *   return a + b;\n * });\n *\n * // you can pass custom arguments + retrieve result values.\n * var sum = eventBus.fire('sum', 1, 2);\n * console.log(sum); // 3\n * ```\n *\n * @template [EventMap=null]\n */\nexport default function EventBus() {\n\n  /**\n   * @type { Record<string, EventBusListener> }\n   */\n  this._listeners = {};\n\n  // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n\n/**\n * @overlord\n *\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @template T\n *\n * @param {string|string[]} events to subscribe to\n * @param {number} [priority=1000] listen priority\n * @param {EventBusEventCallback<T>} callback\n * @param {any} [that] callback context\n */\n/**\n * Register an event listener for events with the given name.\n *\n * The callback will be invoked with `event, ...additionalArguments`\n * that have been passed to {@link EventBus#fire}.\n *\n * Returning false from a listener will prevent the events default action\n * (if any is specified). To stop an event from being processed further in\n * other listeners execute {@link Event#stopPropagation}.\n *\n * Returning anything but `undefined` from a listener will stop the listener propagation.\n *\n * @template {keyof EventMap} EventName\n *\n * @param {EventName} events to subscribe to\n * @param {number} [priority=1000] listen priority\n * @param {EventBusEventCallback<EventMap[EventName]>} callback\n * @param {any} [that] callback context\n */\nEventBus.prototype.on = function(events, priority, callback, that) {\n\n  events = isArray(events) ? events : [ events ];\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  var actualCallback = callback;\n\n  if (that) {\n    actualCallback = bind(callback, that);\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n\n  var self = this;\n\n  events.forEach(function(e) {\n    self._addListener(e, {\n      priority: priority,\n      callback: actualCallback,\n      next: null\n    });\n  });\n};\n\n/**\n * @overlord\n *\n * Register an event listener that is called only once.\n *\n * @template T\n *\n * @param {string|string[]} events to subscribe to\n * @param {number} [priority=1000] the listen priority\n * @param {EventBusEventCallback<T>} callback\n * @param {any} [that] callback context\n */\n/**\n * Register an event listener that is called only once.\n *\n * @template {keyof EventMap} EventName\n *\n * @param {EventName} events to subscribe to\n * @param {number} [priority=1000] listen priority\n * @param {EventBusEventCallback<EventMap[EventName]>} callback\n * @param {any} [that] callback context\n */\nEventBus.prototype.once = function(events, priority, callback, that) {\n  var self = this;\n\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n\n  function wrappedCallback() {\n    wrappedCallback.__isTomb = true;\n\n    var result = callback.apply(that, arguments);\n\n    self.off(events, wrappedCallback);\n\n    return result;\n  }\n\n  // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n  wrappedCallback[FN_REF] = callback;\n\n  this.on(events, priority, wrappedCallback);\n};\n\n\n/**\n * Removes event listeners by event and callback.\n *\n * If no callback is given, all listeners for a given event name are being removed.\n *\n * @param {string|string[]} events\n * @param {EventBusEventCallback} [callback]\n */\nEventBus.prototype.off = function(events, callback) {\n\n  events = isArray(events) ? events : [ events ];\n\n  var self = this;\n\n  events.forEach(function(event) {\n    self._removeListener(event, callback);\n  });\n\n};\n\n\n/**\n * Create an event recognized be the event bus.\n *\n * @param {Object} data Event data.\n *\n * @return {Event} An event that will be recognized by the event bus.\n */\nEventBus.prototype.createEvent = function(data) {\n  var event = new InternalEvent();\n\n  event.init(data);\n\n  return event;\n};\n\n\n/**\n * Fires an event.\n *\n * @example\n *\n * ```javascript\n * // fire event by name\n * events.fire('foo');\n *\n * // fire event object with nested type\n * var event = { type: 'foo' };\n * events.fire(event);\n *\n * // fire event with explicit type\n * var event = { x: 10, y: 20 };\n * events.fire('element.moved', event);\n *\n * // pass additional arguments to the event\n * events.on('foo', function(event, bar) {\n *   alert(bar);\n * });\n *\n * events.fire({ type: 'foo' }, 'I am bar!');\n * ```\n *\n * @param {string} [type] event type\n * @param {Object} [data] event or event data\n * @param {...any} [args] additional arguments the callback will be called with.\n *\n * @return {any} The return value. Will be set to `false` if the default was prevented.\n */\nEventBus.prototype.fire = function(type, data) {\n  var event,\n      firstListener,\n      returnValue,\n      args;\n\n  args = slice.call(arguments);\n\n  if (typeof type === 'object') {\n    data = type;\n    type = data.type;\n  }\n\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n\n  firstListener = this._listeners[type];\n\n  if (!firstListener) {\n    return;\n  }\n\n  // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n  if (data instanceof InternalEvent) {\n\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = this.createEvent(data);\n  }\n\n  // ensure we pass the event as the first parameter\n  args[0] = event;\n\n  // original event type (in case we delegate)\n  var originalType = event.type;\n\n  // update event type before delegation\n  if (type !== originalType) {\n    event.type = type;\n  }\n\n  try {\n    returnValue = this._invokeListeners(event, args, firstListener);\n  } finally {\n\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  }\n\n  // set the return value to false if the event default\n  // got prevented and no other return value exists\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n\n  return returnValue;\n};\n\n/**\n * Handle an error by firing an event.\n *\n * @param {Error} error The error to be handled.\n *\n * @return {boolean} Whether the error was handled.\n */\nEventBus.prototype.handleError = function(error) {\n  return this.fire('error', { error: error }) === false;\n};\n\n\nEventBus.prototype._destroy = function() {\n  this._listeners = {};\n};\n\n/**\n * @param {Event} event\n * @param {any[]} args\n * @param {EventBusListener} listener\n *\n * @return {any}\n */\nEventBus.prototype._invokeListeners = function(event, args, listener) {\n\n  var returnValue;\n\n  while (listener) {\n\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n\n    returnValue = this._invokeListener(event, args, listener);\n\n    listener = listener.next;\n  }\n\n  return returnValue;\n};\n\n/**\n * @param {Event} event\n * @param {any[]} args\n * @param {EventBusListener} listener\n *\n * @return {any}\n */\nEventBus.prototype._invokeListener = function(event, args, listener) {\n\n  var returnValue;\n\n  if (listener.callback.__isTomb) {\n    return returnValue;\n  }\n\n  try {\n\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args);\n\n    // stop propagation on return value\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    }\n\n    // prevent default on return false\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (error) {\n    if (!this.handleError(error)) {\n      console.error('unhandled error in event listener', error);\n\n      throw error;\n    }\n  }\n\n  return returnValue;\n};\n\n/**\n * Add new listener with a certain priority to the list\n * of listeners (for the given event).\n *\n * The semantics of listener registration / listener execution are\n * first register, first serve: New listeners will always be inserted\n * after existing listeners with the same priority.\n *\n * Example: Inserting two listeners with priority 1000 and 1300\n *\n *    * before: [ 1500, 1500, 1000, 1000 ]\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\n *\n * @param {string} event\n * @param {EventBusListener} newListener\n */\nEventBus.prototype._addListener = function(event, newListener) {\n\n  var listener = this._getListeners(event),\n      previousListener;\n\n  // no prior listeners\n  if (!listener) {\n    this._setListeners(event, newListener);\n\n    return;\n  }\n\n  // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n  while (listener) {\n\n    if (listener.priority < newListener.priority) {\n\n      newListener.next = listener;\n\n      if (previousListener) {\n        previousListener.next = newListener;\n      } else {\n        this._setListeners(event, newListener);\n      }\n\n      return;\n    }\n\n    previousListener = listener;\n    listener = listener.next;\n  }\n\n  // add new listener to back\n  previousListener.next = newListener;\n};\n\n\n/**\n * @param {string} name\n *\n * @return {EventBusListener}\n */\nEventBus.prototype._getListeners = function(name) {\n  return this._listeners[name];\n};\n\n/**\n * @param {string} name\n * @param {EventBusListener} listener\n */\nEventBus.prototype._setListeners = function(name, listener) {\n  this._listeners[name] = listener;\n};\n\nEventBus.prototype._removeListener = function(event, callback) {\n\n  var listener = this._getListeners(event),\n      nextListener,\n      previousListener,\n      listenerCallback;\n\n  if (!callback) {\n\n    // clear listeners\n    this._setListeners(event, null);\n\n    return;\n  }\n\n  while (listener) {\n\n    nextListener = listener.next;\n\n    listenerCallback = listener.callback;\n\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n      if (previousListener) {\n        previousListener.next = nextListener;\n      } else {\n\n        // new first listener\n        this._setListeners(event, nextListener);\n      }\n    }\n\n    previousListener = listener;\n    listener = nextListener;\n  }\n};\n\n/**\n * A event that is emitted via the event bus.\n */\nfunction InternalEvent() { }\n\nInternalEvent.prototype.stopPropagation = function() {\n  this.cancelBubble = true;\n};\n\nInternalEvent.prototype.preventDefault = function() {\n  this.defaultPrevented = true;\n};\n\nInternalEvent.prototype.init = function(data) {\n  assign(this, data || {});\n};\n\n\n/**\n * Invoke function. Be fast...\n *\n * @param {Function} fn\n * @param {any[]} args\n *\n * @return {any}\n */\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}\n"],
  "mappings": "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",
  "names": []
}
