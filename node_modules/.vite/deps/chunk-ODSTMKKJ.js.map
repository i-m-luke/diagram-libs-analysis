{
  "version": 3,
  "sources": ["../../diagram-js/lib/command/CommandStack.js"],
  "sourcesContent": ["import {\n  uniqueBy,\n  isArray\n} from 'min-dash';\n\n/**\n * @typedef {import('didi').Injector} Injector\n *\n * @typedef {import('../core/Types').ElementLike} ElementLike\n *\n * @typedef {import('../core/EventBus').default} EventBus\n * @typedef {import('./CommandHandler').default} CommandHandler\n *\n * @typedef { any } CommandContext\n * @typedef { {\n *   new (...args: any[]) : CommandHandler\n * } } CommandHandlerConstructor\n * @typedef { {\n *   [key: string]: CommandHandler;\n * } } CommandHandlerMap\n * @typedef { {\n *   command: string;\n *   context: any;\n *   id?: any;\n * } } CommandStackAction\n * @typedef { {\n *   actions: CommandStackAction[];\n *   dirty: ElementLike[];\n *   trigger: 'execute' | 'undo' | 'redo' | 'clear' | null;\n *   atomic?: boolean;\n * } } CurrentExecution\n */\n\n/**\n * A service that offers un- and redoable execution of commands.\n *\n * The command stack is responsible for executing modeling actions\n * in a un- and redoable manner. To do this it delegates the actual\n * command execution to {@link CommandHandler}s.\n *\n * Command handlers provide {@link CommandHandler#execute(ctx)} and\n * {@link CommandHandler#revert(ctx)} methods to un- and redo a command\n * identified by a command context.\n *\n *\n * ## Life-Cycle events\n *\n * In the process the command stack fires a number of life-cycle events\n * that other components to participate in the command execution.\n *\n *    * preExecute\n *    * preExecuted\n *    * execute\n *    * executed\n *    * postExecute\n *    * postExecuted\n *    * revert\n *    * reverted\n *\n * A special event is used for validating, whether a command can be\n * performed prior to its execution.\n *\n *    * canExecute\n *\n * Each of the events is fired as `commandStack.{eventName}` and\n * `commandStack.{commandName}.{eventName}`, respectively. This gives\n * components fine grained control on where to hook into.\n *\n * The event object fired transports `command`, the name of the\n * command and `context`, the command context.\n *\n *\n * ## Creating Command Handlers\n *\n * Command handlers should provide the {@link CommandHandler#execute(ctx)}\n * and {@link CommandHandler#revert(ctx)} methods to implement\n * redoing and undoing of a command.\n *\n * A command handler _must_ ensure undo is performed properly in order\n * not to break the undo chain. It must also return the shapes that\n * got changed during the `execute` and `revert` operations.\n *\n * Command handlers may execute other modeling operations (and thus\n * commands) in their `preExecute(d)` and `postExecute(d)` phases. The command\n * stack will properly group all commands together into a logical unit\n * that may be re- and undone atomically.\n *\n * Command handlers must not execute other commands from within their\n * core implementation (`execute`, `revert`).\n *\n *\n * ## Change Tracking\n *\n * During the execution of the CommandStack it will keep track of all\n * elements that have been touched during the command's execution.\n *\n * At the end of the CommandStack execution it will notify interested\n * components via an 'elements.changed' event with all the dirty\n * elements.\n *\n * The event can be picked up by components that are interested in the fact\n * that elements have been changed. One use case for this is updating\n * their graphical representation after moving / resizing or deletion.\n *\n * @see CommandHandler\n *\n * @param {EventBus} eventBus\n * @param {Injector} injector\n */\nexport default function CommandStack(eventBus, injector) {\n\n  /**\n   * A map of all registered command handlers.\n   *\n   * @type {CommandHandlerMap}\n   */\n  this._handlerMap = {};\n\n  /**\n   * A stack containing all re/undoable actions on the diagram\n   *\n   * @type {CommandStackAction[]}\n   */\n  this._stack = [];\n\n  /**\n   * The current index on the stack\n   *\n   * @type {number}\n   */\n  this._stackIdx = -1;\n\n  /**\n   * Current active commandStack execution\n   *\n   * @type {CurrentExecution}\n   */\n  this._currentExecution = {\n    actions: [],\n    dirty: [],\n    trigger: null\n  };\n\n  /**\n   * @type {Injector}\n   */\n  this._injector = injector;\n\n  /**\n   * @type EventBus\n   */\n  this._eventBus = eventBus;\n\n  /**\n   * @type { number }\n   */\n  this._uid = 1;\n\n  eventBus.on([\n    'diagram.destroy',\n    'diagram.clear'\n  ], function() {\n    this.clear(false);\n  }, this);\n}\n\nCommandStack.$inject = [ 'eventBus', 'injector' ];\n\n\n/**\n * Execute a command.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n */\nCommandStack.prototype.execute = function(command, context) {\n  if (!command) {\n    throw new Error('command required');\n  }\n\n  this._currentExecution.trigger = 'execute';\n\n  const action = { command: command, context: context };\n\n  this._pushAction(action);\n  this._internalExecute(action);\n  this._popAction();\n};\n\n\n/**\n * Check whether a command can be executed.\n *\n * Implementors may hook into the mechanism on two ways:\n *\n *   * in event listeners:\n *\n *     Users may prevent the execution via an event listener.\n *     It must prevent the default action for `commandStack.(<command>.)canExecute` events.\n *\n *   * in command handlers:\n *\n *     If the method {@link CommandHandler#canExecute} is implemented in a handler\n *     it will be called to figure out whether the execution is allowed.\n *\n * @param {string} command The command to execute.\n * @param {CommandContext} context The context with which to execute the command.\n *\n * @return {boolean} Whether the command can be executed with the given context.\n */\nCommandStack.prototype.canExecute = function(command, context) {\n\n  const action = { command: command, context: context };\n\n  const handler = this._getHandler(command);\n\n  let result = this._fire(command, 'canExecute', action);\n\n  // handler#canExecute will only be called if no listener\n  // decided on a result already\n  if (result === undefined) {\n    if (!handler) {\n      return false;\n    }\n\n    if (handler.canExecute) {\n      result = handler.canExecute(context);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Clear the command stack, erasing all undo / redo history.\n *\n * @param {boolean} [emit=true] Whether to fire an event. Defaults to `true`.\n */\nCommandStack.prototype.clear = function(emit) {\n  this._stack.length = 0;\n  this._stackIdx = -1;\n\n  if (emit !== false) {\n    this._fire('changed', { trigger: 'clear' });\n  }\n};\n\n\n/**\n * Undo last command(s)\n */\nCommandStack.prototype.undo = function() {\n  let action = this._getUndoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'undo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalUndo(action);\n      next = this._getUndoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Redo last command(s)\n */\nCommandStack.prototype.redo = function() {\n  let action = this._getRedoAction(),\n      next;\n\n  if (action) {\n    this._currentExecution.trigger = 'redo';\n\n    this._pushAction(action);\n\n    while (action) {\n      this._internalExecute(action, true);\n      next = this._getRedoAction();\n\n      if (!next || next.id !== action.id) {\n        break;\n      }\n\n      action = next;\n    }\n\n    this._popAction();\n  }\n};\n\n\n/**\n * Register a handler instance with the command stack.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandler} handler Handler to execute the command.\n */\nCommandStack.prototype.register = function(command, handler) {\n  this._setHandler(command, handler);\n};\n\n\n/**\n * Register a handler type with the command stack  by instantiating it and\n * injecting its dependencies.\n *\n * @param {string} command Command to be executed.\n * @param {CommandHandlerConstructor} handlerCls Constructor to instantiate a {@link CommandHandler}.\n */\nCommandStack.prototype.registerHandler = function(command, handlerCls) {\n\n  if (!command || !handlerCls) {\n    throw new Error('command and handlerCls must be defined');\n  }\n\n  const handler = this._injector.instantiate(handlerCls);\n  this.register(command, handler);\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canUndo = function() {\n  return !!this._getUndoAction();\n};\n\n/**\n * @return {boolean}\n */\nCommandStack.prototype.canRedo = function() {\n  return !!this._getRedoAction();\n};\n\n// stack access  //////////////////////\n\nCommandStack.prototype._getRedoAction = function() {\n  return this._stack[this._stackIdx + 1];\n};\n\n\nCommandStack.prototype._getUndoAction = function() {\n  return this._stack[this._stackIdx];\n};\n\n\n// internal functionality //////////////////////\n\nCommandStack.prototype._internalUndo = function(action) {\n  const command = action.command,\n        context = action.context;\n\n  const handler = this._getHandler(command);\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n    this._fire(command, 'revert', action);\n\n    if (handler.revert) {\n      this._markDirty(handler.revert(context));\n    }\n\n    this._revertedAction(action);\n\n    this._fire(command, 'reverted', action);\n  });\n};\n\n\nCommandStack.prototype._fire = function(command, qualifier, event) {\n  if (arguments.length < 3) {\n    event = qualifier;\n    qualifier = null;\n  }\n\n  const names = qualifier ? [ command + '.' + qualifier, qualifier ] : [ command ];\n  let result;\n\n  event = this._eventBus.createEvent(event);\n\n  for (const name of names) {\n    result = this._eventBus.fire('commandStack.' + name, event);\n\n    if (event.cancelBubble) {\n      break;\n    }\n  }\n\n  return result;\n};\n\nCommandStack.prototype._createId = function() {\n  return this._uid++;\n};\n\nCommandStack.prototype._atomicDo = function(fn) {\n\n  const execution = this._currentExecution;\n\n  execution.atomic = true;\n\n  try {\n    fn();\n  } finally {\n    execution.atomic = false;\n  }\n};\n\nCommandStack.prototype._internalExecute = function(action, redo) {\n  const command = action.command,\n        context = action.context;\n\n  const handler = this._getHandler(command);\n\n  if (!handler) {\n    throw new Error('no command handler registered for <' + command + '>');\n  }\n\n  this._pushAction(action);\n\n  if (!redo) {\n    this._fire(command, 'preExecute', action);\n\n    if (handler.preExecute) {\n      handler.preExecute(context);\n    }\n\n    this._fire(command, 'preExecuted', action);\n  }\n\n  // guard against illegal nested command stack invocations\n  this._atomicDo(() => {\n\n    this._fire(command, 'execute', action);\n\n    if (handler.execute) {\n\n      // actual execute + mark return results as dirty\n      this._markDirty(handler.execute(context));\n    }\n\n    // log to stack\n    this._executedAction(action, redo);\n\n    this._fire(command, 'executed', action);\n  });\n\n  if (!redo) {\n    this._fire(command, 'postExecute', action);\n\n    if (handler.postExecute) {\n      handler.postExecute(context);\n    }\n\n    this._fire(command, 'postExecuted', action);\n  }\n\n  this._popAction();\n};\n\n\nCommandStack.prototype._pushAction = function(action) {\n\n  const execution = this._currentExecution,\n        actions = execution.actions;\n\n  const baseAction = actions[0];\n\n  if (execution.atomic) {\n    throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');\n  }\n\n  if (!action.id) {\n    action.id = (baseAction && baseAction.id) || this._createId();\n  }\n\n  actions.push(action);\n};\n\n\nCommandStack.prototype._popAction = function() {\n  const execution = this._currentExecution,\n        trigger = execution.trigger,\n        actions = execution.actions,\n        dirty = execution.dirty;\n\n  actions.pop();\n\n  if (!actions.length) {\n    this._eventBus.fire('elements.changed', { elements: uniqueBy('id', dirty.reverse()) });\n\n    dirty.length = 0;\n\n    this._fire('changed', { trigger: trigger });\n\n    execution.trigger = null;\n  }\n};\n\n\nCommandStack.prototype._markDirty = function(elements) {\n  const execution = this._currentExecution;\n\n  if (!elements) {\n    return;\n  }\n\n  elements = isArray(elements) ? elements : [ elements ];\n\n  execution.dirty = execution.dirty.concat(elements);\n};\n\n\nCommandStack.prototype._executedAction = function(action, redo) {\n  const stackIdx = ++this._stackIdx;\n\n  if (!redo) {\n    this._stack.splice(stackIdx, this._stack.length, action);\n  }\n};\n\n\nCommandStack.prototype._revertedAction = function(action) {\n  this._stackIdx--;\n};\n\n\nCommandStack.prototype._getHandler = function(command) {\n  return this._handlerMap[command];\n};\n\nCommandStack.prototype._setHandler = function(command, handler) {\n  if (!command || !handler) {\n    throw new Error('command and handler required');\n  }\n\n  if (this._handlerMap[command]) {\n    throw new Error('overriding handler for command <' + command + '>');\n  }\n\n  this._handlerMap[command] = handler;\n};\n"],
  "mappings": ";;;;;;AA6Ge,SAAR,aAA8B,UAAU,UAAU;AAOvD,OAAK,cAAc,CAAC;AAOpB,OAAK,SAAS,CAAC;AAOf,OAAK,YAAY;AAOjB,OAAK,oBAAoB;AAAA,IACvB,SAAS,CAAC;AAAA,IACV,OAAO,CAAC;AAAA,IACR,SAAS;AAAA,EACX;AAKA,OAAK,YAAY;AAKjB,OAAK,YAAY;AAKjB,OAAK,OAAO;AAEZ,WAAS,GAAG;AAAA,IACV;AAAA,IACA;AAAA,EACF,GAAG,WAAW;AACZ,SAAK,MAAM,KAAK;AAAA,EAClB,GAAG,IAAI;AACT;AAEA,aAAa,UAAU,CAAE,YAAY,UAAW;AAShD,aAAa,UAAU,UAAU,SAAS,SAAS,SAAS;AAC1D,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AAEA,OAAK,kBAAkB,UAAU;AAEjC,QAAM,SAAS,EAAE,SAAkB,QAAiB;AAEpD,OAAK,YAAY,MAAM;AACvB,OAAK,iBAAiB,MAAM;AAC5B,OAAK,WAAW;AAClB;AAuBA,aAAa,UAAU,aAAa,SAAS,SAAS,SAAS;AAE7D,QAAM,SAAS,EAAE,SAAkB,QAAiB;AAEpD,QAAM,UAAU,KAAK,YAAY,OAAO;AAExC,MAAI,SAAS,KAAK,MAAM,SAAS,cAAc,MAAM;AAIrD,MAAI,WAAW,QAAW;AACxB,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ,YAAY;AACtB,eAAS,QAAQ,WAAW,OAAO;AAAA,IACrC;AAAA,EACF;AAEA,SAAO;AACT;AAQA,aAAa,UAAU,QAAQ,SAAS,MAAM;AAC5C,OAAK,OAAO,SAAS;AACrB,OAAK,YAAY;AAEjB,MAAI,SAAS,OAAO;AAClB,SAAK,MAAM,WAAW,EAAE,SAAS,QAAQ,CAAC;AAAA,EAC5C;AACF;AAMA,aAAa,UAAU,OAAO,WAAW;AACvC,MAAI,SAAS,KAAK,eAAe,GAC7B;AAEJ,MAAI,QAAQ;AACV,SAAK,kBAAkB,UAAU;AAEjC,SAAK,YAAY,MAAM;AAEvB,WAAO,QAAQ;AACb,WAAK,cAAc,MAAM;AACzB,aAAO,KAAK,eAAe;AAE3B,UAAI,CAAC,QAAQ,KAAK,OAAO,OAAO,IAAI;AAClC;AAAA,MACF;AAEA,eAAS;AAAA,IACX;AAEA,SAAK,WAAW;AAAA,EAClB;AACF;AAMA,aAAa,UAAU,OAAO,WAAW;AACvC,MAAI,SAAS,KAAK,eAAe,GAC7B;AAEJ,MAAI,QAAQ;AACV,SAAK,kBAAkB,UAAU;AAEjC,SAAK,YAAY,MAAM;AAEvB,WAAO,QAAQ;AACb,WAAK,iBAAiB,QAAQ,IAAI;AAClC,aAAO,KAAK,eAAe;AAE3B,UAAI,CAAC,QAAQ,KAAK,OAAO,OAAO,IAAI;AAClC;AAAA,MACF;AAEA,eAAS;AAAA,IACX;AAEA,SAAK,WAAW;AAAA,EAClB;AACF;AASA,aAAa,UAAU,WAAW,SAAS,SAAS,SAAS;AAC3D,OAAK,YAAY,SAAS,OAAO;AACnC;AAUA,aAAa,UAAU,kBAAkB,SAAS,SAAS,YAAY;AAErE,MAAI,CAAC,WAAW,CAAC,YAAY;AAC3B,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AAEA,QAAM,UAAU,KAAK,UAAU,YAAY,UAAU;AACrD,OAAK,SAAS,SAAS,OAAO;AAChC;AAKA,aAAa,UAAU,UAAU,WAAW;AAC1C,SAAO,CAAC,CAAC,KAAK,eAAe;AAC/B;AAKA,aAAa,UAAU,UAAU,WAAW;AAC1C,SAAO,CAAC,CAAC,KAAK,eAAe;AAC/B;AAIA,aAAa,UAAU,iBAAiB,WAAW;AACjD,SAAO,KAAK,OAAO,KAAK,YAAY,CAAC;AACvC;AAGA,aAAa,UAAU,iBAAiB,WAAW;AACjD,SAAO,KAAK,OAAO,KAAK,SAAS;AACnC;AAKA,aAAa,UAAU,gBAAgB,SAAS,QAAQ;AACtD,QAAM,UAAU,OAAO,SACjB,UAAU,OAAO;AAEvB,QAAM,UAAU,KAAK,YAAY,OAAO;AAGxC,OAAK,UAAU,MAAM;AACnB,SAAK,MAAM,SAAS,UAAU,MAAM;AAEpC,QAAI,QAAQ,QAAQ;AAClB,WAAK,WAAW,QAAQ,OAAO,OAAO,CAAC;AAAA,IACzC;AAEA,SAAK,gBAAgB,MAAM;AAE3B,SAAK,MAAM,SAAS,YAAY,MAAM;AAAA,EACxC,CAAC;AACH;AAGA,aAAa,UAAU,QAAQ,SAAS,SAAS,WAAW,OAAO;AACjE,MAAI,UAAU,SAAS,GAAG;AACxB,YAAQ;AACR,gBAAY;AAAA,EACd;AAEA,QAAM,QAAQ,YAAY,CAAE,UAAU,MAAM,WAAW,SAAU,IAAI,CAAE,OAAQ;AAC/E,MAAI;AAEJ,UAAQ,KAAK,UAAU,YAAY,KAAK;AAExC,aAAW,QAAQ,OAAO;AACxB,aAAS,KAAK,UAAU,KAAK,kBAAkB,MAAM,KAAK;AAE1D,QAAI,MAAM,cAAc;AACtB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,aAAa,UAAU,YAAY,WAAW;AAC5C,SAAO,KAAK;AACd;AAEA,aAAa,UAAU,YAAY,SAAS,IAAI;AAE9C,QAAM,YAAY,KAAK;AAEvB,YAAU,SAAS;AAEnB,MAAI;AACF,OAAG;AAAA,EACL,UAAE;AACA,cAAU,SAAS;AAAA,EACrB;AACF;AAEA,aAAa,UAAU,mBAAmB,SAAS,QAAQ,MAAM;AAC/D,QAAM,UAAU,OAAO,SACjB,UAAU,OAAO;AAEvB,QAAM,UAAU,KAAK,YAAY,OAAO;AAExC,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,wCAAwC,UAAU,GAAG;AAAA,EACvE;AAEA,OAAK,YAAY,MAAM;AAEvB,MAAI,CAAC,MAAM;AACT,SAAK,MAAM,SAAS,cAAc,MAAM;AAExC,QAAI,QAAQ,YAAY;AACtB,cAAQ,WAAW,OAAO;AAAA,IAC5B;AAEA,SAAK,MAAM,SAAS,eAAe,MAAM;AAAA,EAC3C;AAGA,OAAK,UAAU,MAAM;AAEnB,SAAK,MAAM,SAAS,WAAW,MAAM;AAErC,QAAI,QAAQ,SAAS;AAGnB,WAAK,WAAW,QAAQ,QAAQ,OAAO,CAAC;AAAA,IAC1C;AAGA,SAAK,gBAAgB,QAAQ,IAAI;AAEjC,SAAK,MAAM,SAAS,YAAY,MAAM;AAAA,EACxC,CAAC;AAED,MAAI,CAAC,MAAM;AACT,SAAK,MAAM,SAAS,eAAe,MAAM;AAEzC,QAAI,QAAQ,aAAa;AACvB,cAAQ,YAAY,OAAO;AAAA,IAC7B;AAEA,SAAK,MAAM,SAAS,gBAAgB,MAAM;AAAA,EAC5C;AAEA,OAAK,WAAW;AAClB;AAGA,aAAa,UAAU,cAAc,SAAS,QAAQ;AAEpD,QAAM,YAAY,KAAK,mBACjB,UAAU,UAAU;AAE1B,QAAM,aAAa,QAAQ,CAAC;AAE5B,MAAI,UAAU,QAAQ;AACpB,UAAM,IAAI,MAAM,gEAAgE,OAAO,UAAU,GAAG;AAAA,EACtG;AAEA,MAAI,CAAC,OAAO,IAAI;AACd,WAAO,KAAM,cAAc,WAAW,MAAO,KAAK,UAAU;AAAA,EAC9D;AAEA,UAAQ,KAAK,MAAM;AACrB;AAGA,aAAa,UAAU,aAAa,WAAW;AAC7C,QAAM,YAAY,KAAK,mBACjB,UAAU,UAAU,SACpB,UAAU,UAAU,SACpB,QAAQ,UAAU;AAExB,UAAQ,IAAI;AAEZ,MAAI,CAAC,QAAQ,QAAQ;AACnB,SAAK,UAAU,KAAK,oBAAoB,EAAE,UAAU,SAAS,MAAM,MAAM,QAAQ,CAAC,EAAE,CAAC;AAErF,UAAM,SAAS;AAEf,SAAK,MAAM,WAAW,EAAE,QAAiB,CAAC;AAE1C,cAAU,UAAU;AAAA,EACtB;AACF;AAGA,aAAa,UAAU,aAAa,SAAS,UAAU;AACrD,QAAM,YAAY,KAAK;AAEvB,MAAI,CAAC,UAAU;AACb;AAAA,EACF;AAEA,aAAW,QAAQ,QAAQ,IAAI,WAAW,CAAE,QAAS;AAErD,YAAU,QAAQ,UAAU,MAAM,OAAO,QAAQ;AACnD;AAGA,aAAa,UAAU,kBAAkB,SAAS,QAAQ,MAAM;AAC9D,QAAM,WAAW,EAAE,KAAK;AAExB,MAAI,CAAC,MAAM;AACT,SAAK,OAAO,OAAO,UAAU,KAAK,OAAO,QAAQ,MAAM;AAAA,EACzD;AACF;AAGA,aAAa,UAAU,kBAAkB,SAAS,QAAQ;AACxD,OAAK;AACP;AAGA,aAAa,UAAU,cAAc,SAAS,SAAS;AACrD,SAAO,KAAK,YAAY,OAAO;AACjC;AAEA,aAAa,UAAU,cAAc,SAAS,SAAS,SAAS;AAC9D,MAAI,CAAC,WAAW,CAAC,SAAS;AACxB,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAEA,MAAI,KAAK,YAAY,OAAO,GAAG;AAC7B,UAAM,IAAI,MAAM,qCAAqC,UAAU,GAAG;AAAA,EACpE;AAEA,OAAK,YAAY,OAAO,IAAI;AAC9B;",
  "names": []
}
