{
  "version": 3,
  "sources": ["../../min-dom/node_modules/min-dash/dist/index.esm.js", "../../min-dom/lib/style.js", "../../min-dom/lib/attr.js", "../../min-dom/lib/classes.js", "../../min-dom/lib/clear.js", "../../min-dom/lib/closest.js", "../../min-dom/node_modules/component-event/index.js", "../../min-dom/lib/delegate.js", "../../min-dom/node_modules/domify/index.js", "../../min-dom/lib/matches.js", "../../min-dom/lib/query.js", "../../min-dom/lib/remove.js", "../../diagram-js/lib/core/Canvas.js"],
  "sourcesContent": ["/**\n * Flatten array, one level deep.\n *\n * @template T\n *\n * @param {T[][] | T[] | null} [arr]\n *\n * @return {T[]}\n */\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nconst nativeToString = Object.prototype.toString;\nconst nativeHasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isUndefined(obj) {\n  return obj === undefined;\n}\n\nfunction isDefined(obj) {\n  return obj !== undefined;\n}\n\nfunction isNil(obj) {\n  return obj == null;\n}\n\nfunction isArray(obj) {\n  return nativeToString.call(obj) === '[object Array]';\n}\n\nfunction isObject(obj) {\n  return nativeToString.call(obj) === '[object Object]';\n}\n\nfunction isNumber(obj) {\n  return nativeToString.call(obj) === '[object Number]';\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isFunction(obj) {\n  const tag = nativeToString.call(obj);\n\n  return (\n    tag === '[object Function]' ||\n    tag === '[object AsyncFunction]' ||\n    tag === '[object GeneratorFunction]' ||\n    tag === '[object AsyncGeneratorFunction]' ||\n    tag === '[object Proxy]'\n  );\n}\n\nfunction isString(obj) {\n  return nativeToString.call(obj) === '[object String]';\n}\n\n\n/**\n * Ensure collection is an array.\n *\n * @param {Object} obj\n */\nfunction ensureArray(obj) {\n\n  if (isArray(obj)) {\n    return;\n  }\n\n  throw new Error('must supply array');\n}\n\n/**\n * Return true, if target owns a property with the given key.\n *\n * @param {Object} target\n * @param {String} key\n *\n * @return {Boolean}\n */\nfunction has(target, key) {\n  return nativeHasOwnProperty.call(target, key);\n}\n\n/**\n * @template T\n * @typedef { (\n *   ((e: T) => boolean) |\n *   ((e: T, idx: number) => boolean) |\n *   ((e: T, key: string) => boolean) |\n *   string |\n *   number\n * ) } Matcher\n */\n\n/**\n * @template T\n * @template U\n *\n * @typedef { (\n *   ((e: T) => U) | string | number\n * ) } Extractor\n */\n\n\n/**\n * @template T\n * @typedef { (val: T, key: any) => boolean } MatchFn\n */\n\n/**\n * @template T\n * @typedef { T[] } ArrayCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: string]: T } } StringKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { { [key: number]: T } } NumberKeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { StringKeyValueCollection<T> | NumberKeyValueCollection<T> } KeyValueCollection\n */\n\n/**\n * @template T\n * @typedef { KeyValueCollection<T> | ArrayCollection<T> } Collection\n */\n\n/**\n * Find element in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {Object}\n */\nfunction find(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let match;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      match = val;\n\n      return false;\n    }\n  });\n\n  return match;\n\n}\n\n\n/**\n * Find element index in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {number}\n */\nfunction findIndex(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let idx = isArray(collection) ? -1 : undefined;\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      idx = key;\n\n      return false;\n    }\n  });\n\n  return idx;\n}\n\n\n/**\n * Filter elements in collection.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param {Matcher<T>} matcher\n *\n * @return {T[]} result\n */\nfunction filter(collection, matcher) {\n\n  const matchFn = toMatcher(matcher);\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    if (matchFn(val, key)) {\n      result.push(val);\n    }\n  });\n\n  return result;\n}\n\n\n/**\n * Iterate over collection; returning something\n * (non-undefined) will stop iteration.\n *\n * @template T\n * @param {Collection<T>} collection\n * @param { ((item: T, idx: number) => (boolean|void)) | ((item: T, key: string) => (boolean|void)) } iterator\n *\n * @return {T} return result that stopped the iteration\n */\nfunction forEach(collection, iterator) {\n\n  let val,\n      result;\n\n  if (isUndefined(collection)) {\n    return;\n  }\n\n  const convertKey = isArray(collection) ? toNum : identity;\n\n  for (let key in collection) {\n\n    if (has(collection, key)) {\n      val = collection[key];\n\n      result = iterator(val, convertKey(key));\n\n      if (result === false) {\n        return val;\n      }\n    }\n  }\n}\n\n/**\n * Return collection without element.\n *\n * @template T\n * @param {ArrayCollection<T>} arr\n * @param {Matcher<T>} matcher\n *\n * @return {T[]}\n */\nfunction without(arr, matcher) {\n\n  if (isUndefined(arr)) {\n    return [];\n  }\n\n  ensureArray(arr);\n\n  const matchFn = toMatcher(matcher);\n\n  return arr.filter(function(el, idx) {\n    return !matchFn(el, idx);\n  });\n\n}\n\n\n/**\n * Reduce collection, returning a single result.\n *\n * @template T\n * @template V\n *\n * @param {Collection<T>} collection\n * @param {(result: V, entry: T, index: any) => V} iterator\n * @param {V} result\n *\n * @return {V} result returned from last iterator\n */\nfunction reduce(collection, iterator, result) {\n\n  forEach(collection, function(value, idx) {\n    result = iterator(result, value, idx);\n  });\n\n  return result;\n}\n\n\n/**\n * Return true if every element in the collection\n * matches the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction every(collection, matcher) {\n\n  return !!reduce(collection, function(matches, val, key) {\n    return matches && matcher(val, key);\n  }, true);\n}\n\n\n/**\n * Return true if some elements in the collection\n * match the criteria.\n *\n * @param  {Object|Array} collection\n * @param  {Function} matcher\n *\n * @return {Boolean}\n */\nfunction some(collection, matcher) {\n\n  return !!find(collection, matcher);\n}\n\n\n/**\n * Transform a collection into another collection\n * by piping each member through the given fn.\n *\n * @param  {Object|Array}   collection\n * @param  {Function} fn\n *\n * @return {Array} transformed collection\n */\nfunction map(collection, fn) {\n\n  let result = [];\n\n  forEach(collection, function(val, key) {\n    result.push(fn(val, key));\n  });\n\n  return result;\n}\n\n\n/**\n * Get the collections keys.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction keys(collection) {\n  return collection && Object.keys(collection) || [];\n}\n\n\n/**\n * Shorthand for `keys(o).length`.\n *\n * @param  {Object|Array} collection\n *\n * @return {Number}\n */\nfunction size(collection) {\n  return keys(collection).length;\n}\n\n\n/**\n * Get the values in the collection.\n *\n * @param  {Object|Array} collection\n *\n * @return {Array}\n */\nfunction values(collection) {\n  return map(collection, (val) => val);\n}\n\n\n/**\n * Group collection members by attribute.\n *\n * @param {Object|Array} collection\n * @param {Extractor} extractor\n *\n * @return {Object} map with { attrValue => [ a, b, c ] }\n */\nfunction groupBy(collection, extractor, grouped = {}) {\n\n  extractor = toExtractor(extractor);\n\n  forEach(collection, function(val) {\n    let discriminator = extractor(val) || '_';\n\n    let group = grouped[discriminator];\n\n    if (!group) {\n      group = grouped[discriminator] = [];\n    }\n\n    group.push(val);\n  });\n\n  return grouped;\n}\n\n\nfunction uniqueBy(extractor, ...collections) {\n\n  extractor = toExtractor(extractor);\n\n  let grouped = {};\n\n  forEach(collections, (c) => groupBy(c, extractor, grouped));\n\n  let result = map(grouped, function(val, key) {\n    return val[0];\n  });\n\n  return result;\n}\n\n\nconst unionBy = uniqueBy;\n\n\n\n/**\n * Sort collection by criteria.\n *\n * @template T\n *\n * @param {Collection<T>} collection\n * @param {Extractor<T, number | string>} extractor\n *\n * @return {Array}\n */\nfunction sortBy(collection, extractor) {\n\n  extractor = toExtractor(extractor);\n\n  let sorted = [];\n\n  forEach(collection, function(value, key) {\n    let disc = extractor(value, key);\n\n    let entry = {\n      d: disc,\n      v: value\n    };\n\n    for (var idx = 0; idx < sorted.length; idx++) {\n      let { d } = sorted[idx];\n\n      if (disc < d) {\n        sorted.splice(idx, 0, entry);\n        return;\n      }\n    }\n\n    // not inserted, append (!)\n    sorted.push(entry);\n  });\n\n  return map(sorted, (e) => e.v);\n}\n\n\n/**\n * Create an object pattern matcher.\n *\n * @example\n *\n * ```javascript\n * const matcher = matchPattern({ id: 1 });\n *\n * let element = find(elements, matcher);\n * ```\n *\n * @template T\n *\n * @param {T} pattern\n *\n * @return { (el: any) =>  boolean } matcherFn\n */\nfunction matchPattern(pattern) {\n\n  return function(el) {\n\n    return every(pattern, function(val, key) {\n      return el[key] === val;\n    });\n\n  };\n}\n\n\n/**\n * @param {string | ((e: any) => any) } extractor\n *\n * @return { (e: any) => any }\n */\nfunction toExtractor(extractor) {\n\n  /**\n   * @satisfies { (e: any) => any }\n   */\n  return isFunction(extractor) ? extractor : (e) => {\n\n    // @ts-ignore: just works\n    return e[extractor];\n  };\n}\n\n\n/**\n * @template T\n * @param {Matcher<T>} matcher\n *\n * @return {MatchFn<T>}\n */\nfunction toMatcher(matcher) {\n  return isFunction(matcher) ? matcher : (e) => {\n    return e === matcher;\n  };\n}\n\n\nfunction identity(arg) {\n  return arg;\n}\n\nfunction toNum(arg) {\n  return Number(arg);\n}\n\n/* global setTimeout clearTimeout */\n\n/**\n * @typedef { {\n *   (...args: any[]): any;\n *   flush: () => void;\n *   cancel: () => void;\n * } } DebouncedFunction\n */\n\n/**\n * Debounce fn, calling it only once if the given time\n * elapsed between calls.\n *\n * Lodash-style the function exposes methods to `#clear`\n * and `#flush` to control internal behavior.\n *\n * @param  {Function} fn\n * @param  {Number} timeout\n *\n * @return {DebouncedFunction} debounced function\n */\nfunction debounce(fn, timeout) {\n\n  let timer;\n\n  let lastArgs;\n  let lastThis;\n\n  let lastNow;\n\n  function fire(force) {\n\n    let now = Date.now();\n\n    let scheduledDiff = force ? 0 : (lastNow + timeout) - now;\n\n    if (scheduledDiff > 0) {\n      return schedule(scheduledDiff);\n    }\n\n    fn.apply(lastThis, lastArgs);\n\n    clear();\n  }\n\n  function schedule(timeout) {\n    timer = setTimeout(fire, timeout);\n  }\n\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = lastNow = lastArgs = lastThis = undefined;\n  }\n\n  function flush() {\n    if (timer) {\n      fire(true);\n    }\n\n    clear();\n  }\n\n  /**\n   * @type { DebouncedFunction }\n   */\n  function callback(...args) {\n    lastNow = Date.now();\n\n    lastArgs = args;\n    lastThis = this;\n\n    // ensure an execution is scheduled\n    if (!timer) {\n      schedule(timeout);\n    }\n  }\n\n  callback.flush = flush;\n  callback.cancel = clear;\n\n  return callback;\n}\n\n/**\n * Throttle fn, calling at most once\n * in the given interval.\n *\n * @param  {Function} fn\n * @param  {Number} interval\n *\n * @return {Function} throttled function\n */\nfunction throttle(fn, interval) {\n  let throttling = false;\n\n  return function(...args) {\n\n    if (throttling) {\n      return;\n    }\n\n    fn(...args);\n    throttling = true;\n\n    setTimeout(() => {\n      throttling = false;\n    }, interval);\n  };\n}\n\n/**\n * Bind function against target <this>.\n *\n * @param  {Function} fn\n * @param  {Object}   target\n *\n * @return {Function} bound function\n */\nfunction bind(fn, target) {\n  return fn.bind(target);\n}\n\n/**\n * Convenience wrapper for `Object.assign`.\n *\n * @param {Object} target\n * @param {...Object} others\n *\n * @return {Object} the target\n */\nfunction assign(target, ...others) {\n  return Object.assign(target, ...others);\n}\n\n/**\n * Sets a nested property of a given object to the specified value.\n *\n * This mutates the object and returns it.\n *\n * @template T\n *\n * @param {T} target The target of the set operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} value The value to set.\n *\n * @return {T}\n */\nfunction set(target, path, value) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key, idx) {\n\n    if (typeof key !== 'number' && typeof key !== 'string') {\n      throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');\n    }\n\n    if (key === 'constructor') {\n      throw new Error('illegal key: constructor');\n    }\n\n    if (key === '__proto__') {\n      throw new Error('illegal key: __proto__');\n    }\n\n    let nextKey = path[idx + 1];\n    let nextTarget = currentTarget[key];\n\n    if (isDefined(nextKey) && isNil(nextTarget)) {\n      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];\n    }\n\n    if (isUndefined(nextKey)) {\n      if (isUndefined(value)) {\n        delete currentTarget[key];\n      } else {\n        currentTarget[key] = value;\n      }\n    } else {\n      currentTarget = nextTarget;\n    }\n  });\n\n  return target;\n}\n\n\n/**\n * Gets a nested property of a given object.\n *\n * @param {Object} target The target of the get operation.\n * @param {(string|number)[]} path The path to the nested value.\n * @param {any} [defaultValue] The value to return if no value exists.\n *\n * @return {any}\n */\nfunction get(target, path, defaultValue) {\n\n  let currentTarget = target;\n\n  forEach(path, function(key) {\n\n    // accessing nil property yields <undefined>\n    if (isNil(currentTarget)) {\n      currentTarget = undefined;\n\n      return false;\n    }\n\n    currentTarget = currentTarget[key];\n  });\n\n  return isUndefined(currentTarget) ? defaultValue : currentTarget;\n}\n\n/**\n * Pick properties from the given target.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return Pick<T, V>\n */\nfunction pick(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(properties, function(prop) {\n\n    if (prop in obj) {\n      result[prop] = target[prop];\n    }\n  });\n\n  return result;\n}\n\n/**\n * Pick all target properties, excluding the given ones.\n *\n * @template T\n * @template {any[]} V\n *\n * @param {T} target\n * @param {V} properties\n *\n * @return {Omit<T, V>} target\n */\nfunction omit(target, properties) {\n\n  let result = {};\n\n  let obj = Object(target);\n\n  forEach(obj, function(prop, key) {\n\n    if (properties.indexOf(key) === -1) {\n      result[key] = prop;\n    }\n  });\n\n  return result;\n}\n\n/**\n * Recursively merge `...sources` into given target.\n *\n * Does support merging objects; does not support merging arrays.\n *\n * @param {Object} target\n * @param {...Object} sources\n *\n * @return {Object} the target\n */\nfunction merge(target, ...sources) {\n\n  if (!sources.length) {\n    return target;\n  }\n\n  forEach(sources, function(source) {\n\n    // skip non-obj sources, i.e. null\n    if (!source || !isObject(source)) {\n      return;\n    }\n\n    forEach(source, function(sourceVal, key) {\n\n      if (key === '__proto__') {\n        return;\n      }\n\n      let targetVal = target[key];\n\n      if (isObject(sourceVal)) {\n\n        if (!isObject(targetVal)) {\n\n          // override target[key] with object\n          targetVal = {};\n        }\n\n        target[key] = merge(targetVal, sourceVal);\n      } else {\n        target[key] = sourceVal;\n      }\n\n    });\n  });\n\n  return target;\n}\n\nexport { assign, bind, debounce, ensureArray, every, filter, find, findIndex, flatten, forEach, get, groupBy, has, isArray, isDefined, isFunction, isNil, isNumber, isObject, isString, isUndefined, keys, map, matchPattern, merge, omit, pick, reduce, set, size, some, sortBy, throttle, unionBy, uniqueBy, values, without };\n", "import { forEach } from 'min-dash';\n\n/**\n * Assigns style attributes in a style-src compliant way.\n *\n * @param {Element} element\n * @param {...Object} styleSources\n *\n * @return {Element} the element\n */\nexport function assign(element, ...styleSources) {\n  const target = element.style;\n\n  forEach(styleSources, function(style) {\n    if (!style) {\n      return;\n    }\n\n    forEach(style, function(value, key) {\n      target[key] = value;\n    });\n  });\n\n  return element;\n}\n", "/**\n * Set attribute `name` to `val`, or get attr `name`.\n *\n * @param {Element} el\n * @param {String} name\n * @param {String} [val]\n * @api public\n */\nexport default function attr(el, name, val) {\n\n  // get\n  if (arguments.length == 2) {\n    return el.getAttribute(name);\n  }\n\n  // remove\n  if (val === null) {\n    return el.removeAttribute(name);\n  }\n\n  // set\n  el.setAttribute(name, val);\n\n  return el;\n}", "/**\n * Taken from https://github.com/component/classes\n *\n * Without the component bits.\n */\n\n/**\n * toString reference.\n */\n\nconst toString = Object.prototype.toString;\n\n/**\n * Wrap `el` in a `ClassList`.\n *\n * @param {Element} el\n * @return {ClassList}\n * @api public\n */\n\nexport default function classes(el) {\n  return new ClassList(el);\n}\n\n/**\n * Initialize a new ClassList for `el`.\n *\n * @param {Element} el\n * @api private\n */\n\nfunction ClassList(el) {\n  if (!el || !el.nodeType) {\n    throw new Error('A DOM element reference is required');\n  }\n  this.el = el;\n  this.list = el.classList;\n}\n\n/**\n * Add class `name` if not already present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.add = function(name) {\n  this.list.add(name);\n  return this;\n};\n\n/**\n * Remove class `name` when present, or\n * pass a regular expression to remove\n * any which match.\n *\n * @param {String|RegExp} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.remove = function(name) {\n  if ('[object RegExp]' == toString.call(name)) {\n    return this.removeMatching(name);\n  }\n\n  this.list.remove(name);\n  return this;\n};\n\n/**\n * Remove all classes matching `re`.\n *\n * @param {RegExp} re\n * @return {ClassList}\n * @api private\n */\n\nClassList.prototype.removeMatching = function(re) {\n  const arr = this.array();\n  for (let i = 0; i < arr.length; i++) {\n    if (re.test(arr[i])) {\n      this.remove(arr[i]);\n    }\n  }\n  return this;\n};\n\n/**\n * Toggle class `name`, can force state via `force`.\n *\n * For browsers that support classList, but do not support `force` yet,\n * the mistake will be detected and corrected.\n *\n * @param {String} name\n * @param {Boolean} force\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.toggle = function(name, force) {\n  if ('undefined' !== typeof force) {\n    if (force !== this.list.toggle(name, force)) {\n      this.list.toggle(name); // toggle again to correct\n    }\n  } else {\n    this.list.toggle(name);\n  }\n  return this;\n};\n\n/**\n * Return an array of classes.\n *\n * @return {Array}\n * @api public\n */\n\nClassList.prototype.array = function() {\n  return Array.from(this.list);\n};\n\n/**\n * Check if class `name` is present.\n *\n * @param {String} name\n * @return {ClassList}\n * @api public\n */\n\nClassList.prototype.has =\nClassList.prototype.contains = function(name) {\n  return this.list.contains(name);\n};\n", "/**\n * Clear utility\n */\n\n/**\n * Removes all children from the given element\n *\n * @param {Element} element\n *\n * @return {Element} the element (for chaining)\n */\nexport default function clear(element) {\n  var child;\n\n  while ((child = element.firstChild)) {\n    element.removeChild(child);\n  }\n\n  return element;\n}", "/**\n * Closest\n *\n * @param {Element} el\n * @param {string} selector\n * @param {boolean} checkYourSelf (optional)\n */\nexport default function(element, selector, checkYourSelf) {\n  var actualElement = checkYourSelf ? element : element.parentNode;\n\n  return actualElement && typeof actualElement.closest === 'function' && actualElement.closest(selector) || null;\n}\n", "var bind, unbind, prefix;\n\nfunction detect () {\n  bind = window.addEventListener ? 'addEventListener' : 'attachEvent';\n  unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent';\n  prefix = bind !== 'addEventListener' ? 'on' : '';\n}\n\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  if (!bind) detect();\n  el[bind](prefix + type, fn, capture || false);\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  if (!unbind) detect();\n  el[unbind](prefix + type, fn, capture || false);\n  return fn;\n};\n", "/**\n * Module dependencies.\n */\n\nimport closest from './closest';\nimport event from './event';\n\n/**\n * Delegate event `type` to `selector`\n * and invoke `fn(e)`. A callback function\n * is returned which may be passed to `.unbind()`.\n *\n * @param {Element} el\n * @param {String} selector\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\n// Some events don't bubble, so we want to bind to the capture phase instead\n// when delegating.\nvar forceCaptureEvents = [ 'focus', 'blur' ];\n\nfunction bind(el, selector, type, fn, capture) {\n  if (forceCaptureEvents.indexOf(type) !== -1) {\n    capture = true;\n  }\n\n  return event.bind(el, type, function(e) {\n    var target = e.target || e.srcElement;\n    e.delegateTarget = closest(target, selector, true, el);\n    if (e.delegateTarget) {\n      fn.call(el, e);\n    }\n  }, capture);\n}\n\n/**\n * Unbind event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @api public\n */\nfunction unbind(el, type, fn, capture) {\n  if (forceCaptureEvents.indexOf(type) !== -1) {\n    capture = true;\n  }\n\n  return event.unbind(el, type, fn, capture);\n}\n\nexport default {\n  bind,\n  unbind\n};", "\n/**\n * Expose `parse`.\n */\n\nmodule.exports = parse;\n\n/**\n * Tests for browser support.\n */\n\nvar innerHTMLBug = false;\nvar bugTestDiv;\nif (typeof document !== 'undefined') {\n  bugTestDiv = document.createElement('div');\n  // Setup\n  bugTestDiv.innerHTML = '  <link/><table></table><a href=\"/a\">a</a><input type=\"checkbox\"/>';\n  // Make sure that link elements get serialized correctly by innerHTML\n  // This requires a wrapper element in IE\n  innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;\n  bugTestDiv = undefined;\n}\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  legend: [1, '<fieldset>', '</fieldset>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  // for script/link/style tags to work in IE6-8, you have to wrap\n  // in a div with a non-whitespace character in front, ha!\n  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']\n};\n\nmap.td =\nmap.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nmap.option =\nmap.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>'];\n\nmap.polyline =\nmap.ellipse =\nmap.polygon =\nmap.circle =\nmap.text =\nmap.line =\nmap.path =\nmap.rect =\nmap.g = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">','</svg>'];\n\n/**\n * Parse `html` and return a DOM Node instance, which could be a TextNode,\n * HTML DOM Node of some kind (<div> for example), or a DocumentFragment\n * instance, depending on the contents of the `html` string.\n *\n * @param {String} html - HTML string to \"domify\"\n * @param {Document} doc - The `document` instance to create the Node for\n * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance\n * @api private\n */\n\nfunction parse(html, doc) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n\n  // default to the global `document` object\n  if (!doc) doc = document;\n\n  // tag name\n  var m = /<([\\w:]+)/.exec(html);\n  if (!m) return doc.createTextNode(html);\n\n  html = html.replace(/^\\s+|\\s+$/g, ''); // Remove leading/trailing whitespace\n\n  var tag = m[1];\n\n  // body support\n  if (tag == 'body') {\n    var el = doc.createElement('html');\n    el.innerHTML = html;\n    return el.removeChild(el.lastChild);\n  }\n\n  // wrap map\n  var wrap = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = doc.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  // one element\n  if (el.firstChild == el.lastChild) {\n    return el.removeChild(el.firstChild);\n  }\n\n  // several elements\n  var fragment = doc.createDocumentFragment();\n  while (el.firstChild) {\n    fragment.appendChild(el.removeChild(el.firstChild));\n  }\n\n  return fragment;\n}\n", "/**\n * @param { HTMLElement } element\n * @param { String } selector\n *\n * @return { boolean }\n */\nexport default function matches(element, selector) {\n  return element && typeof element.matches === 'function' && element.matches(selector) || false;\n}", "export default function query(selector, el) {\n  el = el || document;\n\n  return el.querySelector(selector);\n}\n\nexport function all(selector, el) {\n  el = el || document;\n\n  return el.querySelectorAll(selector);\n}", "export default function remove(el) {\n  el.parentNode && el.parentNode.removeChild(el);\n}", "import {\n  isNumber,\n  assign,\n  forEach,\n  every,\n  debounce,\n  bind,\n  reduce,\n  find\n} from 'min-dash';\n\nimport {\n  assignStyle\n} from 'min-dom';\n\nimport {\n  add as collectionAdd,\n  remove as collectionRemove\n} from '../util/Collections';\n\nimport {\n  getType,\n  getBBox as getBoundingBox\n} from '../util/Elements';\n\nimport { asTRBL } from '../layout/LayoutUtil';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  classes as svgClasses,\n  create as svgCreate,\n  transform as svgTransform,\n  remove as svgRemove\n} from 'tiny-svg';\n\nimport { createMatrix as createMatrix } from 'tiny-svg';\n\n\n/**\n * @typedef {import('./Types').ConnectionLike} ConnectionLike\n * @typedef {import('./Types').RootLike} RootLike\n * @typedef {import('./Types').ParentLike } ParentLike\n * @typedef {import('./Types').ShapeLike} ShapeLike\n *\n * @typedef { {\n *   container?: HTMLElement;\n *   deferUpdate?: boolean;\n *   width?: number;\n *   height?: number;\n * } } CanvasConfig\n * @typedef { {\n *   group: SVGElement;\n *   index: number;\n *   visible: boolean;\n * } } CanvasLayer\n * @typedef { {\n *   [key: string]: CanvasLayer;\n * } } CanvasLayers\n * @typedef { {\n *   rootElement: ShapeLike;\n *   layer: CanvasLayer;\n * } } CanvasPlane\n * @typedef { {\n *   scale: number;\n *   inner: Rect;\n *   outer: Dimensions;\n * } & Rect } CanvasViewbox\n *\n * @typedef {import('./ElementRegistry').default} ElementRegistry\n * @typedef {import('./EventBus').default} EventBus\n * @typedef {import('./GraphicsFactory').default} GraphicsFactory\n *\n * @typedef {import('../util/Types').Dimensions} Dimensions\n * @typedef {import('../util/Types').Point} Point\n * @typedef {import('../util/Types').Rect} Rect\n * @typedef {import('../util/Types').RectTRBL} RectTRBL\n * @typedef {import('../util/Types').ScrollDelta} ScrollDelta\n */\n\nfunction round(number, resolution) {\n  return Math.round(number * resolution) / resolution;\n}\n\nfunction ensurePx(number) {\n  return isNumber(number) ? number + 'px' : number;\n}\n\nfunction findRoot(element) {\n  while (element.parent) {\n    element = element.parent;\n  }\n\n  return element;\n}\n\n/**\n * Creates a HTML container element for a SVG element with\n * the given configuration\n *\n * @param {CanvasConfig} options\n *\n * @return {HTMLElement} the container element\n */\nfunction createContainer(options) {\n\n  options = assign({}, { width: '100%', height: '100%' }, options);\n\n  const container = options.container || document.body;\n\n  // create a <div> around the svg element with the respective size\n  // this way we can always get the correct container size\n  // (this is impossible for <svg> elements at the moment)\n  const parent = document.createElement('div');\n  parent.setAttribute('class', 'djs-container djs-parent');\n\n  assignStyle(parent, {\n    position: 'relative',\n    overflow: 'hidden',\n    width: ensurePx(options.width),\n    height: ensurePx(options.height)\n  });\n\n  container.appendChild(parent);\n\n  return parent;\n}\n\nfunction createGroup(parent, cls, childIndex) {\n  const group = svgCreate('g');\n  svgClasses(group).add(cls);\n\n  const index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;\n\n  // must ensure second argument is node or _null_\n  // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore\n  parent.insertBefore(group, parent.childNodes[index] || null);\n\n  return group;\n}\n\nconst BASE_LAYER = 'base';\n\n// render plane contents behind utility layers\nconst PLANE_LAYER_INDEX = 0;\nconst UTILITY_LAYER_INDEX = 1;\n\n\nconst REQUIRED_MODEL_ATTRS = {\n  shape: [ 'x', 'y', 'width', 'height' ],\n  connection: [ 'waypoints' ]\n};\n\n/**\n * The main drawing canvas.\n *\n * @class\n * @constructor\n *\n * @emits Canvas#canvas.init\n *\n * @param {CanvasConfig|null} config\n * @param {EventBus} eventBus\n * @param {GraphicsFactory} graphicsFactory\n * @param {ElementRegistry} elementRegistry\n */\nexport default function Canvas(config, eventBus, graphicsFactory, elementRegistry) {\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n  this._graphicsFactory = graphicsFactory;\n\n  /**\n   * @type {number}\n   */\n  this._rootsIdx = 0;\n\n  /**\n   * @type {CanvasLayers}\n   */\n  this._layers = {};\n\n  /**\n   * @type {CanvasPlane[]}\n   */\n  this._planes = [];\n\n  /**\n   * @type {RootLike|null}\n   */\n  this._rootElement = null;\n\n  this._init(config || {});\n}\n\nCanvas.$inject = [\n  'config.canvas',\n  'eventBus',\n  'graphicsFactory',\n  'elementRegistry'\n];\n\n/**\n * Creates a <svg> element that is wrapped into a <div>.\n * This way we are always able to correctly figure out the size of the svg element\n * by querying the parent node.\n\n * (It is not possible to get the size of a svg element cross browser @ 2014-04-01)\n\n * <div class=\"djs-container\" style=\"width: {desired-width}, height: {desired-height}\">\n *   <svg width=\"100%\" height=\"100%\">\n *    ...\n *   </svg>\n * </div>\n *\n * @param {CanvasConfig} config\n */\nCanvas.prototype._init = function(config) {\n\n  const eventBus = this._eventBus;\n\n  // html container\n  const container = this._container = createContainer(config);\n\n  const svg = this._svg = svgCreate('svg');\n  svgAttr(svg, { width: '100%', height: '100%' });\n\n  svgAppend(container, svg);\n\n  const viewport = this._viewport = createGroup(svg, 'viewport');\n\n  // debounce canvas.viewbox.changed events when deferUpdate is set\n  // to help with potential performance issues\n  if (config.deferUpdate) {\n    this._viewboxChanged = debounce(bind(this._viewboxChanged, this), 300);\n  }\n\n  eventBus.on('diagram.init', () => {\n\n    /**\n     * An event indicating that the canvas is ready to be drawn on.\n     *\n     * @memberOf Canvas\n     *\n     * @event canvas.init\n     *\n     * @type {Object}\n     * @property {SVGElement} svg the created svg element\n     * @property {SVGElement} viewport the direct parent of diagram elements and shapes\n     */\n    eventBus.fire('canvas.init', {\n      svg: svg,\n      viewport: viewport\n    });\n\n  });\n\n  // reset viewbox on shape changes to\n  // recompute the viewbox\n  eventBus.on([\n    'shape.added',\n    'connection.added',\n    'shape.removed',\n    'connection.removed',\n    'elements.changed',\n    'root.set'\n  ], () => {\n    delete this._cachedViewbox;\n  });\n\n  eventBus.on('diagram.destroy', 500, this._destroy, this);\n  eventBus.on('diagram.clear', 500, this._clear, this);\n};\n\nCanvas.prototype._destroy = function() {\n  this._eventBus.fire('canvas.destroy', {\n    svg: this._svg,\n    viewport: this._viewport\n  });\n\n  const parent = this._container.parentNode;\n\n  if (parent) {\n    parent.removeChild(this._container);\n  }\n\n  delete this._svg;\n  delete this._container;\n  delete this._layers;\n  delete this._planes;\n  delete this._rootElement;\n  delete this._viewport;\n};\n\nCanvas.prototype._clear = function() {\n\n  const allElements = this._elementRegistry.getAll();\n\n  // remove all elements\n  allElements.forEach(element => {\n    const type = getType(element);\n\n    if (type === 'root') {\n      this.removeRootElement(element);\n    } else {\n      this._removeElement(element, type);\n    }\n  });\n\n  // remove all planes\n  this._planes = [];\n  this._rootElement = null;\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n};\n\n/**\n * Returns the default layer on which\n * all elements are drawn.\n *\n * @return {SVGElement}  The SVG element of the layer.\n */\nCanvas.prototype.getDefaultLayer = function() {\n  return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);\n};\n\n/**\n * Returns a layer that is used to draw elements\n * or annotations on it.\n *\n * Non-existing layers retrieved through this method\n * will be created. During creation, the optional index\n * may be used to create layers below or above existing layers.\n * A layer with a certain index is always created above all\n * existing layers with the same index.\n *\n * @param {string} name The name of the layer.\n * @param {number} [index] The index of the layer.\n *\n * @return {SVGElement} The SVG element of the layer.\n */\nCanvas.prototype.getLayer = function(name, index) {\n\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n\n  let layer = this._layers[name];\n\n  if (!layer) {\n    layer = this._layers[name] = this._createLayer(name, index);\n  }\n\n  // throw an error if layer creation / retrival is\n  // requested on different index\n  if (typeof index !== 'undefined' && layer.index !== index) {\n    throw new Error('layer <' + name + '> already created at index <' + index + '>');\n  }\n\n  return layer.group;\n};\n\n/**\n * For a given index, return the number of layers that have a higher index and\n * are visible.\n *\n * This is used to determine the node a layer should be inserted at.\n *\n * @param {number} index\n *\n * @return {number}\n */\nCanvas.prototype._getChildIndex = function(index) {\n  return reduce(this._layers, function(childIndex, layer) {\n    if (layer.visible && index >= layer.index) {\n      childIndex++;\n    }\n\n    return childIndex;\n  }, 0);\n};\n\n/**\n * Creates a given layer and returns it.\n *\n * @param {string} name\n * @param {number} [index=0]\n *\n * @return {CanvasLayer}\n */\nCanvas.prototype._createLayer = function(name, index) {\n\n  if (typeof index === 'undefined') {\n    index = UTILITY_LAYER_INDEX;\n  }\n\n  const childIndex = this._getChildIndex(index);\n\n  return {\n    group: createGroup(this._viewport, 'layer-' + name, childIndex),\n    index: index,\n    visible: true\n  };\n};\n\n\n/**\n * Shows a given layer.\n *\n * @param {string} name The name of the layer.\n *\n * @return {SVGElement} The SVG element of the layer.\n */\nCanvas.prototype.showLayer = function(name) {\n\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n\n  const layer = this._layers[name];\n\n  if (!layer) {\n    throw new Error('layer <' + name + '> does not exist');\n  }\n\n  const viewport = this._viewport;\n  const group = layer.group;\n  const index = layer.index;\n\n  if (layer.visible) {\n    return group;\n  }\n\n  const childIndex = this._getChildIndex(index);\n\n  viewport.insertBefore(group, viewport.childNodes[childIndex] || null);\n\n  layer.visible = true;\n\n  return group;\n};\n\n/**\n * Hides a given layer.\n *\n * @param {string} name The name of the layer.\n *\n * @return {SVGElement} The SVG element of the layer.\n */\nCanvas.prototype.hideLayer = function(name) {\n\n  if (!name) {\n    throw new Error('must specify a name');\n  }\n\n  const layer = this._layers[name];\n\n  if (!layer) {\n    throw new Error('layer <' + name + '> does not exist');\n  }\n\n  const group = layer.group;\n\n  if (!layer.visible) {\n    return group;\n  }\n\n  svgRemove(group);\n\n  layer.visible = false;\n\n  return group;\n};\n\n\nCanvas.prototype._removeLayer = function(name) {\n\n  const layer = this._layers[name];\n\n  if (layer) {\n    delete this._layers[name];\n\n    svgRemove(layer.group);\n  }\n};\n\n/**\n * Returns the currently active layer. Can be null.\n *\n * @return {CanvasLayer|null} The active layer of `null`.\n */\nCanvas.prototype.getActiveLayer = function() {\n  const plane = this._findPlaneForRoot(this.getRootElement());\n\n  if (!plane) {\n    return null;\n  }\n\n  return plane.layer;\n};\n\n\n/**\n * Returns the plane which contains the given element.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n *\n * @return {RootLike|undefined} The root of the element.\n */\nCanvas.prototype.findRoot = function(element) {\n  if (typeof element === 'string') {\n    element = this._elementRegistry.get(element);\n  }\n\n  if (!element) {\n    return;\n  }\n\n  const plane = this._findPlaneForRoot(\n    findRoot(element)\n  ) || {};\n\n  return plane.rootElement;\n};\n\n/**\n * Return a list of all root elements on the diagram.\n *\n * @return {(RootLike)[]} The list of root elements.\n */\nCanvas.prototype.getRootElements = function() {\n  return this._planes.map(function(plane) {\n    return plane.rootElement;\n  });\n};\n\nCanvas.prototype._findPlaneForRoot = function(rootElement) {\n  return find(this._planes, function(plane) {\n    return plane.rootElement === rootElement;\n  });\n};\n\n\n/**\n * Returns the html element that encloses the\n * drawing canvas.\n *\n * @return {HTMLElement} The HTML element of the container.\n */\nCanvas.prototype.getContainer = function() {\n  return this._container;\n};\n\n\n// markers //////////////////////\n\nCanvas.prototype._updateMarker = function(element, marker, add) {\n  let container;\n\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  element.markers = element.markers || new Set();\n\n  // we need to access all\n  container = this._elementRegistry._elements[element.id];\n\n  if (!container) {\n    return;\n  }\n\n  forEach([ container.gfx, container.secondaryGfx ], function(gfx) {\n    if (gfx) {\n\n      // invoke either addClass or removeClass based on mode\n      if (add) {\n        element.markers.add(marker);\n        svgClasses(gfx).add(marker);\n      } else {\n        element.markers.delete(marker);\n        svgClasses(gfx).remove(marker);\n      }\n    }\n  });\n\n  /**\n   * An event indicating that a marker has been updated for an element\n   *\n   * @event element.marker.update\n   * @type {Object}\n   * @property {Element} element the shape\n   * @property {SVGElement} gfx the graphical representation of the shape\n   * @property {string} marker\n   * @property {boolean} add true if the marker was added, false if it got removed\n   */\n  this._eventBus.fire('element.marker.update', { element: element, gfx: container.gfx, marker: marker, add: !!add });\n};\n\n\n/**\n * Adds a marker to an element (basically a css class).\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @example\n *\n * ```javascript\n * canvas.addMarker('foo', 'some-marker');\n *\n * const fooGfx = canvas.getGraphics('foo');\n *\n * fooGfx; // <g class=\"... some-marker\"> ... </g>\n * ```\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n * @param {string} marker The marker.\n */\nCanvas.prototype.addMarker = function(element, marker) {\n  this._updateMarker(element, marker, true);\n};\n\n\n/**\n * Remove a marker from an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n * @param {string} marker The marker.\n */\nCanvas.prototype.removeMarker = function(element, marker) {\n  this._updateMarker(element, marker, false);\n};\n\n/**\n * Check whether an element has a given marker.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n * @param {string} marker The marker.\n */\nCanvas.prototype.hasMarker = function(element, marker) {\n  if (!element.id) {\n    element = this._elementRegistry.get(element);\n  }\n\n  if (!element.markers) {\n    return false;\n  }\n\n  return element.markers.has(marker);\n};\n\n/**\n * Toggles a marker on an element.\n *\n * Fires the element.marker.update event, making it possible to\n * integrate extension into the marker life-cycle, too.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n * @param {string} marker The marker.\n */\nCanvas.prototype.toggleMarker = function(element, marker) {\n  if (this.hasMarker(element, marker)) {\n    this.removeMarker(element, marker);\n  } else {\n    this.addMarker(element, marker);\n  }\n};\n\n/**\n * Returns the current root element.\n *\n * Supports two different modes for handling root elements:\n *\n * 1. if no root element has been added before, an implicit root will be added\n * and returned. This is used in applications that don't require explicit\n * root elements.\n *\n * 2. when root elements have been added before calling `getRootElement`,\n * root elements can be null. This is used for applications that want to manage\n * root elements themselves.\n *\n * @return {RootLike} The current root element.\n */\nCanvas.prototype.getRootElement = function() {\n  const rootElement = this._rootElement;\n\n  // can return null if root elements are present but none was set yet\n  if (rootElement || this._planes.length) {\n    return rootElement;\n  }\n\n  return this.setRootElement(this.addRootElement(null));\n};\n\n/**\n * Adds a given root element and returns it.\n *\n * @param {RootLike} [rootElement] The root element to be added.\n *\n * @return {RootLike} The added root element or an implicit root element.\n */\nCanvas.prototype.addRootElement = function(rootElement) {\n  const idx = this._rootsIdx++;\n\n  if (!rootElement) {\n    rootElement = {\n      id: '__implicitroot_' + idx,\n      children: [],\n      isImplicit: true\n    };\n  }\n\n  const layerName = rootElement.layer = 'root-' + idx;\n\n  this._ensureValid('root', rootElement);\n\n  const layer = this.getLayer(layerName, PLANE_LAYER_INDEX);\n\n  this.hideLayer(layerName);\n\n  this._addRoot(rootElement, layer);\n\n  this._planes.push({\n    rootElement: rootElement,\n    layer: layer\n  });\n\n  return rootElement;\n};\n\n/**\n * Removes a given root element and returns it.\n *\n * @param {RootLike|string} rootElement element or element ID\n *\n * @return {RootLike|undefined} removed element\n */\nCanvas.prototype.removeRootElement = function(rootElement) {\n\n  if (typeof rootElement === 'string') {\n    rootElement = this._elementRegistry.get(rootElement);\n  }\n\n  const plane = this._findPlaneForRoot(rootElement);\n\n  if (!plane) {\n    return;\n  }\n\n  // hook up life-cycle events\n  this._removeRoot(rootElement);\n\n  // clean up layer\n  this._removeLayer(rootElement.layer);\n\n  // clean up plane\n  this._planes = this._planes.filter(function(plane) {\n    return plane.rootElement !== rootElement;\n  });\n\n  // clean up active root\n  if (this._rootElement === rootElement) {\n    this._rootElement = null;\n  }\n\n  return rootElement;\n};\n\n\n/**\n * Sets a given element as the new root element for the canvas\n * and returns the new root element.\n *\n * @param {RootLike} rootElement The root element to be set.\n *\n * @return {RootLike} The set root element.\n */\nCanvas.prototype.setRootElement = function(rootElement) {\n\n  if (rootElement === this._rootElement) {\n    return rootElement;\n  }\n\n  let plane;\n\n  if (!rootElement) {\n    throw new Error('rootElement required');\n  }\n\n  plane = this._findPlaneForRoot(rootElement);\n\n  // give set add semantics for backwards compatibility\n  if (!plane) {\n    rootElement = this.addRootElement(rootElement);\n  }\n\n  this._setRoot(rootElement);\n\n  return rootElement;\n};\n\n\nCanvas.prototype._removeRoot = function(element) {\n  const elementRegistry = this._elementRegistry,\n        eventBus = this._eventBus;\n\n  // simulate element remove event sequence\n  eventBus.fire('root.remove', { element: element });\n  eventBus.fire('root.removed', { element: element });\n\n  elementRegistry.remove(element);\n};\n\n\nCanvas.prototype._addRoot = function(element, gfx) {\n  const elementRegistry = this._elementRegistry,\n        eventBus = this._eventBus;\n\n  // resemble element add event sequence\n  eventBus.fire('root.add', { element: element });\n\n  elementRegistry.add(element, gfx);\n\n  eventBus.fire('root.added', { element: element, gfx: gfx });\n};\n\n\nCanvas.prototype._setRoot = function(rootElement, layer) {\n\n  const currentRoot = this._rootElement;\n\n  if (currentRoot) {\n\n    // un-associate previous root element <svg>\n    this._elementRegistry.updateGraphics(currentRoot, null, true);\n\n    // hide previous layer\n    this.hideLayer(currentRoot.layer);\n  }\n\n  if (rootElement) {\n\n    if (!layer) {\n      layer = this._findPlaneForRoot(rootElement).layer;\n    }\n\n    // associate element with <svg>\n    this._elementRegistry.updateGraphics(rootElement, this._svg, true);\n\n    // show root layer\n    this.showLayer(rootElement.layer);\n  }\n\n  this._rootElement = rootElement;\n\n  this._eventBus.fire('root.set', { element: rootElement });\n};\n\nCanvas.prototype._ensureValid = function(type, element) {\n  if (!element.id) {\n    throw new Error('element must have an id');\n  }\n\n  if (this._elementRegistry.get(element.id)) {\n    throw new Error('element <' + element.id + '> already exists');\n  }\n\n  const requiredAttrs = REQUIRED_MODEL_ATTRS[type];\n\n  const valid = every(requiredAttrs, function(attr) {\n    return typeof element[attr] !== 'undefined';\n  });\n\n  if (!valid) {\n    throw new Error(\n      'must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);\n  }\n};\n\nCanvas.prototype._setParent = function(element, parent, parentIndex) {\n  collectionAdd(parent.children, element, parentIndex);\n  element.parent = parent;\n};\n\n/**\n * Adds an element to the canvas.\n *\n * This wires the parent <-> child relationship between the element and\n * a explicitly specified parent or an implicit root element.\n *\n * During add it emits the events\n *\n *  * <{type}.add> (element, parent)\n *  * <{type}.added> (element, gfx)\n *\n * Extensions may hook into these events to perform their magic.\n *\n * @param {string} type\n * @param {ConnectionLike|ShapeLike} element\n * @param {ShapeLike} [parent]\n * @param {number} [parentIndex]\n *\n * @return {ConnectionLike|ShapeLike} The added element.\n */\nCanvas.prototype._addElement = function(type, element, parent, parentIndex) {\n\n  parent = parent || this.getRootElement();\n\n  const eventBus = this._eventBus,\n        graphicsFactory = this._graphicsFactory;\n\n  this._ensureValid(type, element);\n\n  eventBus.fire(type + '.add', { element: element, parent: parent });\n\n  this._setParent(element, parent, parentIndex);\n\n  // create graphics\n  const gfx = graphicsFactory.create(type, element, parentIndex);\n\n  this._elementRegistry.add(element, gfx);\n\n  // update its visual\n  graphicsFactory.update(type, element, gfx);\n\n  eventBus.fire(type + '.added', { element: element, gfx: gfx });\n\n  return element;\n};\n\n/**\n * Adds a shape to the canvas.\n *\n * @param {ShapeLike} shape The shape to be added\n * @param {ParentLike} [parent] The shape's parent.\n * @param {number} [parentIndex] The index at which to add the shape to the parent's children.\n *\n * @return {ShapeLike} The added shape.\n */\nCanvas.prototype.addShape = function(shape, parent, parentIndex) {\n  return this._addElement('shape', shape, parent, parentIndex);\n};\n\n/**\n * Adds a connection to the canvas.\n *\n * @param {ConnectionLike} connection The connection to be added.\n * @param {ParentLike} [parent] The connection's parent.\n * @param {number} [parentIndex] The index at which to add the connection to the parent's children.\n *\n * @return {ConnectionLike} The added connection.\n */\nCanvas.prototype.addConnection = function(connection, parent, parentIndex) {\n  return this._addElement('connection', connection, parent, parentIndex);\n};\n\n\n/**\n * Internal remove element\n */\nCanvas.prototype._removeElement = function(element, type) {\n\n  const elementRegistry = this._elementRegistry,\n        graphicsFactory = this._graphicsFactory,\n        eventBus = this._eventBus;\n\n  element = elementRegistry.get(element.id || element);\n\n  if (!element) {\n\n    // element was removed already\n    return;\n  }\n\n  eventBus.fire(type + '.remove', { element: element });\n\n  graphicsFactory.remove(element);\n\n  // unset parent <-> child relationship\n  collectionRemove(element.parent && element.parent.children, element);\n  element.parent = null;\n\n  eventBus.fire(type + '.removed', { element: element });\n\n  elementRegistry.remove(element);\n\n  return element;\n};\n\n\n/**\n * Removes a shape from the canvas.\n *\n * @fires ShapeRemoveEvent\n * @fires ShapeRemovedEvent\n *\n * @param {ShapeLike|string} shape The shape or its ID.\n *\n * @return {ShapeLike} The removed shape.\n */\nCanvas.prototype.removeShape = function(shape) {\n\n  /**\n   * An event indicating that a shape is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event ShapeRemoveEvent\n   * @type {Object}\n   * @property {ShapeLike} element The shape.\n   * @property {SVGElement} gfx The graphical element.\n   */\n\n  /**\n   * An event indicating that a shape has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event ShapeRemovedEvent\n   * @type {Object}\n   * @property {ShapeLike} element The shape.\n   * @property {SVGElement} gfx The graphical element.\n   */\n  return this._removeElement(shape, 'shape');\n};\n\n\n/**\n * Removes a connection from the canvas.\n *\n * @fires ConnectionRemoveEvent\n * @fires ConnectionRemovedEvent\n *\n * @param {ConnectionLike|string} connection The connection or its ID.\n *\n * @return {ConnectionLike} The removed connection.\n */\nCanvas.prototype.removeConnection = function(connection) {\n\n  /**\n   * An event indicating that a connection is about to be removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event ConnectionRemoveEvent\n   * @type {Object}\n   * @property {ConnectionLike} element The connection.\n   * @property {SVGElement} gfx The graphical element.\n   */\n\n  /**\n   * An event indicating that a connection has been removed from the canvas.\n   *\n   * @memberOf Canvas\n   *\n   * @event ConnectionRemovedEvent\n   * @type {Object}\n   * @property {ConnectionLike} element The connection.\n   * @property {SVGElement} gfx The graphical element.\n   */\n  return this._removeElement(connection, 'connection');\n};\n\n\n/**\n * Returns the graphical element of an element.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element or its ID.\n * @param {boolean} [secondary=false] Whether to return the secondary graphical element.\n *\n * @return {SVGElement} The graphical element.\n */\nCanvas.prototype.getGraphics = function(element, secondary) {\n  return this._elementRegistry.getGraphics(element, secondary);\n};\n\n\n/**\n * Perform a viewbox update via a given change function.\n *\n * @param {Function} changeFn\n */\nCanvas.prototype._changeViewbox = function(changeFn) {\n\n  // notify others of the upcoming viewbox change\n  this._eventBus.fire('canvas.viewbox.changing');\n\n  // perform actual change\n  changeFn.apply(this);\n\n  // reset the cached viewbox so that\n  // a new get operation on viewbox or zoom\n  // triggers a viewbox re-computation\n  this._cachedViewbox = null;\n\n  // notify others of the change; this step\n  // may or may not be debounced\n  this._viewboxChanged();\n};\n\nCanvas.prototype._viewboxChanged = function() {\n  this._eventBus.fire('canvas.viewbox.changed', { viewbox: this.viewbox() });\n};\n\n\n/**\n * Gets or sets the view box of the canvas, i.e. the\n * area that is currently displayed.\n *\n * The getter may return a cached viewbox (if it is currently\n * changing). To force a recomputation, pass `false` as the first argument.\n *\n * @example\n *\n * ```javascript\n * canvas.viewbox({ x: 100, y: 100, width: 500, height: 500 })\n *\n * // sets the visible area of the diagram to (100|100) -> (600|100)\n * // and and scales it according to the diagram width\n *\n * const viewbox = canvas.viewbox(); // pass `false` to force recomputing the box.\n *\n * console.log(viewbox);\n * // {\n * //   inner: Dimensions,\n * //   outer: Dimensions,\n * //   scale,\n * //   x, y,\n * //   width, height\n * // }\n *\n * // if the current diagram is zoomed and scrolled, you may reset it to the\n * // default zoom via this method, too:\n *\n * const zoomedAndScrolledViewbox = canvas.viewbox();\n *\n * canvas.viewbox({\n *   x: 0,\n *   y: 0,\n *   width: zoomedAndScrolledViewbox.outer.width,\n *   height: zoomedAndScrolledViewbox.outer.height\n * });\n * ```\n *\n * @param {Rect} [box] The viewbox to be set.\n *\n * @return {CanvasViewbox} The set viewbox.\n */\nCanvas.prototype.viewbox = function(box) {\n\n  if (box === undefined && this._cachedViewbox) {\n    return structuredClone(this._cachedViewbox);\n  }\n\n  const viewport = this._viewport,\n        outerBox = this.getSize();\n  let innerBox,\n      matrix,\n      activeLayer,\n      transform,\n      scale,\n      x, y;\n\n  if (!box) {\n\n    // compute the inner box based on the\n    // diagrams active layer. This allows us to exclude\n    // external components, such as overlays\n\n    activeLayer = this._rootElement ? this.getActiveLayer() : null;\n    innerBox = activeLayer && activeLayer.getBBox() || {};\n\n    transform = svgTransform(viewport);\n    matrix = transform ? transform.matrix : createMatrix();\n    scale = round(matrix.a, 1000);\n\n    x = round(-matrix.e || 0, 1000);\n    y = round(-matrix.f || 0, 1000);\n\n    box = this._cachedViewbox = {\n      x: x ? x / scale : 0,\n      y: y ? y / scale : 0,\n      width: outerBox.width / scale,\n      height: outerBox.height / scale,\n      scale: scale,\n      inner: {\n        width: innerBox.width || 0,\n        height: innerBox.height || 0,\n        x: innerBox.x || 0,\n        y: innerBox.y || 0\n      },\n      outer: outerBox\n    };\n\n    return box;\n  } else {\n\n    this._changeViewbox(function() {\n      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);\n\n      const matrix = this._svg.createSVGMatrix()\n        .scale(scale)\n        .translate(-box.x, -box.y);\n\n      svgTransform(viewport, matrix);\n    });\n  }\n\n  return box;\n};\n\n\n/**\n * Gets or sets the scroll of the canvas.\n *\n * @param {ScrollDelta} [delta] The scroll to be set.\n *\n * @return {Point}\n */\nCanvas.prototype.scroll = function(delta) {\n\n  const node = this._viewport;\n  let matrix = node.getCTM();\n\n  if (delta) {\n    this._changeViewbox(function() {\n      delta = assign({ dx: 0, dy: 0 }, delta || {});\n\n      matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);\n\n      setCTM(node, matrix);\n    });\n  }\n\n  return { x: matrix.e, y: matrix.f };\n};\n\n/**\n * Scrolls the viewbox to contain the given element.\n * Optionally specify a padding to be applied to the edges.\n *\n * @param {ShapeLike|ConnectionLike|string} element The element to scroll to or its ID.\n * @param {RectTRBL|number} [padding=100] The padding to be applied. Can also specify top, bottom, left and right.\n */\nCanvas.prototype.scrollToElement = function(element, padding) {\n  let defaultPadding = 100;\n\n  if (typeof element === 'string') {\n    element = this._elementRegistry.get(element);\n  }\n\n  // set to correct rootElement\n  const rootElement = this.findRoot(element);\n\n  if (rootElement !== this.getRootElement()) {\n    this.setRootElement(rootElement);\n  }\n\n  // element is rootElement, do not change viewport\n  if (rootElement === element) {\n    return;\n  }\n\n  if (!padding) {\n    padding = {};\n  }\n  if (typeof padding === 'number') {\n    defaultPadding = padding;\n  }\n\n  padding = {\n    top: padding.top || defaultPadding,\n    right: padding.right || defaultPadding,\n    bottom: padding.bottom || defaultPadding,\n    left: padding.left || defaultPadding\n  };\n\n  const elementBounds = getBoundingBox(element),\n        elementTrbl = asTRBL(elementBounds),\n        viewboxBounds = this.viewbox(),\n        zoom = this.zoom();\n  let dx, dy;\n\n  // shrink viewboxBounds with padding\n  viewboxBounds.y += padding.top / zoom;\n  viewboxBounds.x += padding.left / zoom;\n  viewboxBounds.width -= (padding.right + padding.left) / zoom;\n  viewboxBounds.height -= (padding.bottom + padding.top) / zoom;\n\n  const viewboxTrbl = asTRBL(viewboxBounds);\n\n  const canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;\n\n  if (!canFit) {\n\n    // top-left when element can't fit\n    dx = elementBounds.x - viewboxBounds.x;\n    dy = elementBounds.y - viewboxBounds.y;\n\n  } else {\n\n    const dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right),\n          dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left),\n          dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom),\n          dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);\n\n    dx = dRight || dLeft;\n    dy = dBottom || dTop;\n\n  }\n\n  this.scroll({ dx: -dx * zoom, dy: -dy * zoom });\n};\n\n/**\n * Gets or sets the current zoom of the canvas, optionally zooming to the\n * specified position.\n *\n * The getter may return a cached zoom level. Call it with `false` as the first\n * argument to force recomputation of the current level.\n *\n * @param {number|'fit-viewport'} [newScale] The new zoom level, either a number,\n * i.e. 0.9, or `fit-viewport` to adjust the size to fit the current viewport.\n * @param {Point} [center] The reference point { x: ..., y: ...} to zoom to.\n *\n * @return {number} The set zoom level.\n */\nCanvas.prototype.zoom = function(newScale, center) {\n\n  if (!newScale) {\n    return this.viewbox(newScale).scale;\n  }\n\n  if (newScale === 'fit-viewport') {\n    return this._fitViewport(center);\n  }\n\n  let outer,\n      matrix;\n\n  this._changeViewbox(function() {\n\n    if (typeof center !== 'object') {\n      outer = this.viewbox().outer;\n\n      center = {\n        x: outer.width / 2,\n        y: outer.height / 2\n      };\n    }\n\n    matrix = this._setZoom(newScale, center);\n  });\n\n  return round(matrix.a, 1000);\n};\n\nfunction setCTM(node, m) {\n  const mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';\n  node.setAttribute('transform', mstr);\n}\n\nCanvas.prototype._fitViewport = function(center) {\n\n  const vbox = this.viewbox(),\n        outer = vbox.outer,\n        inner = vbox.inner;\n  let newScale,\n      newViewbox;\n\n  // display the complete diagram without zooming in.\n  // instead of relying on internal zoom, we perform a\n  // hard reset on the canvas viewbox to realize this\n  //\n  // if diagram does not need to be zoomed in, we focus it around\n  // the diagram origin instead\n\n  if (inner.x >= 0 &&\n      inner.y >= 0 &&\n      inner.x + inner.width <= outer.width &&\n      inner.y + inner.height <= outer.height &&\n      !center) {\n\n    newViewbox = {\n      x: 0,\n      y: 0,\n      width: Math.max(inner.width + inner.x, outer.width),\n      height: Math.max(inner.height + inner.y, outer.height)\n    };\n  } else {\n\n    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);\n    newViewbox = {\n      x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),\n      y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),\n      width: outer.width / newScale,\n      height: outer.height / newScale\n    };\n  }\n\n  this.viewbox(newViewbox);\n\n  return this.viewbox(false).scale;\n};\n\n\nCanvas.prototype._setZoom = function(scale, center) {\n\n  const svg = this._svg,\n        viewport = this._viewport;\n\n  const matrix = svg.createSVGMatrix();\n  const point = svg.createSVGPoint();\n\n  let centerPoint,\n      originalPoint,\n      currentMatrix,\n      scaleMatrix,\n      newMatrix;\n\n  currentMatrix = viewport.getCTM();\n\n  const currentScale = currentMatrix.a;\n\n  if (center) {\n    centerPoint = assign(point, center);\n\n    // revert applied viewport transformations\n    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());\n\n    // create scale matrix\n    scaleMatrix = matrix\n      .translate(originalPoint.x, originalPoint.y)\n      .scale(1 / currentScale * scale)\n      .translate(-originalPoint.x, -originalPoint.y);\n\n    newMatrix = currentMatrix.multiply(scaleMatrix);\n  } else {\n    newMatrix = matrix.scale(scale);\n  }\n\n  setCTM(this._viewport, newMatrix);\n\n  return newMatrix;\n};\n\n\n/**\n * Returns the size of the canvas.\n *\n * @return {Dimensions} The size of the canvas.\n */\nCanvas.prototype.getSize = function() {\n  return {\n    width: this._container.clientWidth,\n    height: this._container.clientHeight\n  };\n};\n\n\n/**\n * Returns the absolute bounding box of an element.\n *\n * The absolute bounding box may be used to display overlays in the callers\n * (browser) coordinate system rather than the zoomed in/out canvas coordinates.\n *\n * @param {ShapeLike|ConnectionLike} element The element.\n *\n * @return {Rect} The element's absolute bounding box.\n */\nCanvas.prototype.getAbsoluteBBox = function(element) {\n  const vbox = this.viewbox();\n  let bbox;\n\n  // connection\n  // use svg bbox\n  if (element.waypoints) {\n    const gfx = this.getGraphics(element);\n\n    bbox = gfx.getBBox();\n  }\n\n  // shapes\n  // use data\n  else {\n    bbox = element;\n  }\n\n  const x = bbox.x * vbox.scale - vbox.x * vbox.scale;\n  const y = bbox.y * vbox.scale - vbox.y * vbox.scale;\n\n  const width = bbox.width * vbox.scale;\n  const height = bbox.height * vbox.scale;\n\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n};\n\n/**\n * Fires an event so other modules can react to the canvas resizing.\n */\nCanvas.prototype.resized = function() {\n\n  // force recomputation of view box\n  delete this._cachedViewbox;\n\n  this._eventBus.fire('canvas.resized');\n};\n"],
  "mappings": "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",
  "names": ["forEach", "assign", "attr", "classes", "bind", "unbind", "prefix", "remove", "assign", "add", "plane", "attr", "remove", "transform", "matrix"]
}
