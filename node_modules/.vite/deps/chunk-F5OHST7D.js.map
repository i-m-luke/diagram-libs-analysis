{
  "version": 3,
  "sources": ["../../diagram-js/lib/command/CommandInterceptor.js", "../../diagram-js/lib/features/rules/RuleProvider.js"],
  "sourcesContent": ["import {\n  forEach,\n  isFunction,\n  isArray,\n  isNumber,\n  isObject\n} from 'min-dash';\n\n/**\n * @typedef {import('../core/Types').ElementLike} ElementLike\n * @typedef {import('../core/EventBus').default} EventBus\n * @typedef {import('./CommandStack').CommandContext} CommandContext\n *\n * @typedef {string|string[]} Events\n * @typedef { (context: CommandContext) => ElementLike[] | void } HandlerFunction\n * @typedef { (context: CommandContext) => void } ComposeHandlerFunction\n */\n\nvar DEFAULT_PRIORITY = 1000;\n\n/**\n * A utility that can be used to plug into the command execution for\n * extension and/or validation.\n *\n * @class\n * @constructor\n *\n * @example\n *\n * ```javascript\n * import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n *\n * class CommandLogger extends CommandInterceptor {\n *   constructor(eventBus) {\n *     super(eventBus);\n *\n *   this.preExecute('shape.create', (event) => {\n *     console.log('commandStack.shape-create.preExecute', event);\n *   });\n * }\n * ```\n *\n * @param {EventBus} eventBus\n */\nexport default function CommandInterceptor(eventBus) {\n\n  /**\n   * @type {EventBus}\n   */\n  this._eventBus = eventBus;\n}\n\nCommandInterceptor.$inject = [ 'eventBus' ];\n\nfunction unwrapEvent(fn, that) {\n  return function(event) {\n    return fn.call(that || null, event.context, event.command, event);\n  };\n}\n\n\n/**\n * Intercept a command during one of the phases.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {string} [hook] phase to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {\n\n  if (isFunction(hook) || isNumber(hook)) {\n    that = unwrap;\n    unwrap = handlerFn;\n    handlerFn = priority;\n    priority = hook;\n    hook = null;\n  }\n\n  if (isFunction(priority)) {\n    that = unwrap;\n    unwrap = handlerFn;\n    handlerFn = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n\n  if (isObject(unwrap)) {\n    that = unwrap;\n    unwrap = false;\n  }\n\n  if (!isFunction(handlerFn)) {\n    throw new Error('handlerFn must be a function');\n  }\n\n  if (!isArray(events)) {\n    events = [ events ];\n  }\n\n  var eventBus = this._eventBus;\n\n  forEach(events, function(event) {\n\n    // concat commandStack(.event)?(.hook)?\n    var fullEvent = [ 'commandStack', event, hook ].filter(function(e) { return e; }).join('.');\n\n    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);\n  });\n};\n\n/**\n * Add a <canExecute> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.canExecute = createHook('canExecute');\n\n/**\n * Add a <preExecute> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.preExecute = createHook('preExecute');\n\n/**\n * Add a <preExecuted> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.preExecuted = createHook('preExecuted');\n\n/**\n * Add a <execute> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.execute = createHook('execute');\n\n/**\n * Add a <executed> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.executed = createHook('executed');\n\n/**\n * Add a <postExecute> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.postExecute = createHook('postExecute');\n\n/**\n * Add a <postExecuted> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.postExecuted = createHook('postExecuted');\n\n/**\n * Add a <revert> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.revert = createHook('revert');\n\n/**\n * Add a <reverted> phase of command interceptor.\n *\n * @param {Events} [events] command(s) to intercept\n * @param {number} [priority]\n * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n * @param {boolean} [unwrap] whether the event should be unwrapped\n * @param {any} [that]\n */\nCommandInterceptor.prototype.reverted = createHook('reverted');\n\n/*\n * Add prototype methods for each phase of command execution (e.g. execute,\n * revert).\n *\n * @param {string} hook\n *\n * @return { (\n *   events?: Events,\n *   priority?: number,\n *   handlerFn: ComposeHandlerFunction|HandlerFunction,\n *   unwrap?: boolean\n * ) => any }\n */\nfunction createHook(hook) {\n\n  /**\n   * @this {CommandInterceptor}\n   *\n   * @param {Events} [events]\n   * @param {number} [priority]\n   * @param {ComposeHandlerFunction|HandlerFunction} handlerFn\n   * @param {boolean} [unwrap]\n   * @param {any} [that]\n   */\n  const hookFn = function(events, priority, handlerFn, unwrap, that) {\n\n    if (isFunction(events) || isNumber(events)) {\n      that = unwrap;\n      unwrap = handlerFn;\n      handlerFn = priority;\n      priority = events;\n      events = null;\n    }\n\n    this.on(events, hook, priority, handlerFn, unwrap, that);\n  };\n\n  return hookFn;\n}\n", "import inherits from 'inherits-browser';\n\nimport CommandInterceptor from '../../command/CommandInterceptor';\n\n/**\n * @typedef {import('../../core/EventBus').default} EventBus\n */\n\n/**\n * A basic provider that may be extended to implement modeling rules.\n *\n * Extensions should implement the init method to actually add their custom\n * modeling checks. Checks may be added via the #addRule(action, fn) method.\n *\n * @class\n *\n * @param {EventBus} eventBus\n */\nexport default function RuleProvider(eventBus) {\n  CommandInterceptor.call(this, eventBus);\n\n  this.init();\n}\n\nRuleProvider.$inject = [ 'eventBus' ];\n\ninherits(RuleProvider, CommandInterceptor);\n\n\n/**\n * Adds a modeling rule for the given action, implemented through\n * a callback function.\n *\n * The callback receives a modeling specific action context\n * to perform its check. It must return `false` to disallow the\n * action from happening or `true` to allow the action. Usually returing\n * `null` denotes that a particular interaction shall be ignored.\n * By returning nothing or `undefined` you pass evaluation to lower\n * priority rules.\n *\n * @example\n *\n * ```javascript\n * ResizableRules.prototype.init = function() {\n *\n *   \\/**\n *    * Return `true`, `false` or nothing to denote\n *    * _allowed_, _not allowed_ and _continue evaluating_.\n *    *\\/\n *   this.addRule('shape.resize', function(context) {\n *\n *     var shape = context.shape;\n *\n *     if (!context.newBounds) {\n *       // check general resizability\n *       if (!shape.resizable) {\n *         return false;\n *       }\n *\n *       // not returning anything (read: undefined)\n *       // will continue the evaluation of other rules\n *       // (with lower priority)\n *       return;\n *     } else {\n *       // element must have minimum size of 10*10 points\n *       return context.newBounds.width > 10 && context.newBounds.height > 10;\n *     }\n *   });\n * };\n * ```\n *\n * @param {string|string[]} actions the identifier for the modeling action to check\n * @param {number} [priority] the priority at which this rule is being applied\n * @param {(any) => any} fn the callback function that performs the actual check\n */\nRuleProvider.prototype.addRule = function(actions, priority, fn) {\n\n  var self = this;\n\n  if (typeof actions === 'string') {\n    actions = [ actions ];\n  }\n\n  actions.forEach(function(action) {\n\n    self.canExecute(action, priority, function(context, action, event) {\n      return fn(context);\n    }, true);\n  });\n};\n\n/**\n * Implement this method to add new rules during provider initialization.\n */\nRuleProvider.prototype.init = function() {};"],
  "mappings": ";;;;;;;;;;;;AAkBA,IAAI,mBAAmB;AA0BR,SAAR,mBAAoC,UAAU;AAKnD,OAAK,YAAY;AACnB;AAEA,mBAAmB,UAAU,CAAE,UAAW;AAE1C,SAAS,YAAY,IAAI,MAAM;AAC7B,SAAO,SAAS,OAAO;AACrB,WAAO,GAAG,KAAK,QAAQ,MAAM,MAAM,SAAS,MAAM,SAAS,KAAK;AAAA,EAClE;AACF;AAaA,mBAAmB,UAAU,KAAK,SAAS,QAAQ,MAAM,UAAU,WAAW,QAAQ,MAAM;AAE1F,MAAI,WAAW,IAAI,KAAK,SAAS,IAAI,GAAG;AACtC,WAAO;AACP,aAAS;AACT,gBAAY;AACZ,eAAW;AACX,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,QAAQ,GAAG;AACxB,WAAO;AACP,aAAS;AACT,gBAAY;AACZ,eAAW;AAAA,EACb;AAEA,MAAI,SAAS,MAAM,GAAG;AACpB,WAAO;AACP,aAAS;AAAA,EACX;AAEA,MAAI,CAAC,WAAW,SAAS,GAAG;AAC1B,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAChD;AAEA,MAAI,CAAC,QAAQ,MAAM,GAAG;AACpB,aAAS,CAAE,MAAO;AAAA,EACpB;AAEA,MAAI,WAAW,KAAK;AAEpB,UAAQ,QAAQ,SAAS,OAAO;AAG9B,QAAI,YAAY,CAAE,gBAAgB,OAAO,IAAK,EAAE,OAAO,SAASA,IAAG;AAAE,aAAOA;AAAA,IAAG,CAAC,EAAE,KAAK,GAAG;AAE1F,aAAS,GAAG,WAAW,UAAU,SAAS,YAAY,WAAW,IAAI,IAAI,WAAW,IAAI;AAAA,EAC1F,CAAC;AACH;AAWA,mBAAmB,UAAU,aAAa,WAAW,YAAY;AAWjE,mBAAmB,UAAU,aAAa,WAAW,YAAY;AAWjE,mBAAmB,UAAU,cAAc,WAAW,aAAa;AAWnE,mBAAmB,UAAU,UAAU,WAAW,SAAS;AAW3D,mBAAmB,UAAU,WAAW,WAAW,UAAU;AAW7D,mBAAmB,UAAU,cAAc,WAAW,aAAa;AAWnE,mBAAmB,UAAU,eAAe,WAAW,cAAc;AAWrE,mBAAmB,UAAU,SAAS,WAAW,QAAQ;AAWzD,mBAAmB,UAAU,WAAW,WAAW,UAAU;AAe7D,SAAS,WAAW,MAAM;AAWxB,QAAM,SAAS,SAAS,QAAQ,UAAU,WAAW,QAAQ,MAAM;AAEjE,QAAI,WAAW,MAAM,KAAK,SAAS,MAAM,GAAG;AAC1C,aAAO;AACP,eAAS;AACT,kBAAY;AACZ,iBAAW;AACX,eAAS;AAAA,IACX;AAEA,SAAK,GAAG,QAAQ,MAAM,UAAU,WAAW,QAAQ,IAAI;AAAA,EACzD;AAEA,SAAO;AACT;;;ACvOe,SAAR,aAA8B,UAAU;AAC7C,qBAAmB,KAAK,MAAM,QAAQ;AAEtC,OAAK,KAAK;AACZ;AAEA,aAAa,UAAU,CAAE,UAAW;AAEpC,EAAS,cAAc,kBAAkB;AAiDzC,aAAa,UAAU,UAAU,SAAS,SAAS,UAAU,IAAI;AAE/D,MAAI,OAAO;AAEX,MAAI,OAAO,YAAY,UAAU;AAC/B,cAAU,CAAE,OAAQ;AAAA,EACtB;AAEA,UAAQ,QAAQ,SAAS,QAAQ;AAE/B,SAAK,WAAW,QAAQ,UAAU,SAAS,SAASC,SAAQ,OAAO;AACjE,aAAO,GAAG,OAAO;AAAA,IACnB,GAAG,IAAI;AAAA,EACT,CAAC;AACH;AAKA,aAAa,UAAU,OAAO,WAAW;AAAC;",
  "names": ["e", "action"]
}
